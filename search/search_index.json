{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome To Ossum Technology!","text":"<p>This site provides documentation for technologies created at Ossum, Inc.</p> <p>THe sections at the top correspond to our products:</p> <ul> <li>RIDDL</li> <li>Synapify</li> <li>Docify</li> <li>Verify</li> </ul>"},{"location":"#information","title":"Information","text":"<ul> <li>Author: Ossum Inc.</li> <li>Purpose: Documentation of Ossum Inc.'s products</li> <li>Created: 2025</li> <li>Modified: continuously</li> <li>Privacy Policy</li> </ul>"},{"location":"about/","title":"About","text":"<ul> <li>Privacy Policy</li> </ul>"},{"location":"about/privacy-policy/","title":"Privacy Policy","text":""},{"location":"about/privacy-policy/#static-web-site","title":"Static Web Site","text":"<p>This site, https://ossum.tech/ is static. It does not use cookies, has no ability to collect your information, and does not invade your privacy. This site is merely for documentation that you may read without security concerns.  </p>"},{"location":"docify/","title":"Docify","text":"<p>Docify is the tool that turns your (RIDDL)(../riddl/index.md) model into an interactive web site. </p>"},{"location":"riddl/","title":"Overview","text":"<p>RIDDL is the language used to specify system models that can be converted into code using AI. There are many kinds of resources to help you:</p> <ul> <li>Introduction - An introduction to RIDDL that answers fundamental    questions for those that are new. Start here. </li> <li>Guides - provide tutorials and guidance on how various kinds of users would    use RIDDL</li> <li>Reference - reference material most notably used to train AI how to use    RIDDL</li> <li>Tools - Tools you can use to manipulate RIDDL models</li> </ul>"},{"location":"riddl/concepts/","title":"Overview","text":"<p>In this section we will explore the concepts and ideas that RIDDL uses. This is not about the RIDDL language syntax, but about the concepts that the language uses and how they relate to each other.</p>"},{"location":"riddl/concepts/#definitions","title":"Definitions","text":"<p>RIDDL consists only of definitions that define the design of the desired system.  </p>"},{"location":"riddl/concepts/#definitional-hierarchy","title":"Definitional Hierarchy","text":"<p>Definitions in RIDDL are arranged in a hierarchy. Definitions that contain other definitions are known as branches. Definitions that do not contain other definitions are known as leaves.</p> <p>This is done simply by having an attribute that lists the contents of any  definition:</p> <ul> <li>contents: The contained definitions that define the container. Not all    definitions can contain other ones so sometimes this is empty.</li> </ul>"},{"location":"riddl/concepts/#simplifications","title":"Simplifications","text":"<p>The valid hierarchy structure is shown below, but to make this hierarchy  easier to comprehend, we've taken some short-cuts :</p> <ol> <li>All the common attributes     have been omitted for brevity but are implied on each line of the     hierarchy.</li> <li>We only descend as far as a Type definition.     Whenever you see one, you should infer this hierarchy: </li> <li>Types<ul> <li>Fields</li> </ul> </li> </ol>"},{"location":"riddl/concepts/#hierarchy","title":"Hierarchy","text":"<p>With those clarifying simplifications, here's the hierarchy: * Root   * Domain     * Type     * Epic       * Case         * Statement     * Context       * Type       * Group         * Output         * Input       * Entity         * Type         * Function           * Statement         * State           * Type           * Field           * Handler             * On Clause               * Statement         * Invariant           * Conditional         * Handler           * On Clause             * Statement       * Handler         * On Clause           * Statement       * Projector         * Type         * Field         * Handler           * On Clause             * Statement       * Saga         * Type         * SagaStep           * Statement       * Adaptor         * Type         * Handler           * On Clause             * Statement       * Processor         * Type         * Inlet          * Outlet         * Statement       * Function         * Statement       * Streamlet         * Type         * Inlet         * Outlet         * Connector</p>"},{"location":"riddl/concepts/#next","title":"Next","text":"<p>When you're done exploring all the concepts, check out our  guides next.</p>"},{"location":"riddl/concepts/#full-index","title":"Full Index","text":"<p>{{&lt; toc-tree &gt;}}</p>"},{"location":"riddl/concepts/adaptor/","title":"Adaptor","text":"<p>An adaptor's purpose is to adapt one Context to another Context.  In Domain-Driven Design,  this concept is known as an anti-corruption layer that keeps the  ubiquitous language of one context \"corrupting\" the language of another  context.  The authors of RIDDL didn't like that term for a variety of reasons so we have renamed the concept as adaptor in RIDDL. Same idea, different name.</p>"},{"location":"riddl/concepts/adaptor/#message-translation","title":"Message Translation","text":"<p>Adaptors do their work at the level of messages sent between  Contexts. This is done using one or  more Handlers. Each handler specifies  how messages are translated into other messages and forwarded to the target  context.   </p>"},{"location":"riddl/concepts/adaptor/#target-context","title":"Target Context","text":"<p>Adaptors are only definable within a containing  Context which provides one participant of the  translation. The other Context, known as the  target context, is specified within the definition of the adaptor. </p>"},{"location":"riddl/concepts/adaptor/#adaptation-directionality","title":"Adaptation Directionality","text":"<p>Adaptors only translate in one direction, between the containing context and  the target context. However, multiple Adaptors can be defined  to achieve bidirectional adaptation between Contexts.  The directionality of an Adaptor is specified in the definition of the adaptor. This leads to two kinds of adaptors: inbound and outbound.</p>"},{"location":"riddl/concepts/adaptor/#inbound-adaptors","title":"Inbound Adaptors","text":"<p>Inbound adaptors provide an adaptation that occurs from the  Context referenced in the adaptor to the Context containing the adaptor. </p>"},{"location":"riddl/concepts/adaptor/#outbound-adaptors","title":"Outbound Adaptors","text":"<p>Outbound adaptors provide an adaptation that occurs from the Context containing the adaptor to the Context referenced in the adaptor.</p>"},{"location":"riddl/concepts/adaptor/#occurs-in","title":"Occurs In","text":"<ul> <li>Contexts</li> </ul>"},{"location":"riddl/concepts/adaptor/#contains","title":"Contains","text":"<ul> <li>Authors</li> <li>Handlers</li> <li>Terms</li> </ul>"},{"location":"riddl/concepts/application/","title":"Application","text":"<p>An application in RIDDL represents an interface portion of a system where an  user (human or machine) initiates an action on the system. Applications  only define the net result of the interaction between the user and the  application. They are abstract on purpose. That is, there is nothing in RIDDL  that defines how information is provided to a user nor received from a user.  This gives free latitude to the user interface  designer to manage the entire interaction between human and machine. </p> <p>There are also no assumptions about the technology used for the  implementation of an application. RIDDL's notion of an application is general  and abstract, but they can be implemented as any of the following: * Mobile Application On Any Platform * Web Application * Native Operating System Application (graphical or command line) * Interactive Voice Recognition * Virtual Reality with Haptics * and other things yet to be invented. </p> <p>This means a RIDDL application specification can be used as the basis for  creating multiple implementations of the specification using a variety of  technologies.     </p>"},{"location":"riddl/concepts/application/#groups","title":"Groups","text":"<p>Applications abstractly design a user interface by containing a set of  groups. Groups can be nested which allows them to define the structure of a user interface. </p>"},{"location":"riddl/concepts/application/#handlers","title":"Handlers","text":"<p>Applications have message  handlers like many other RIDDL definitions.  However, application handlers only receive their messages from  actors, unlike other handlers. Typically, the  handling of messages in handlers will ultimately send further messages to  other components, like a context or entity</p>"},{"location":"riddl/concepts/application/#occurs-in","title":"Occurs In","text":"<ul> <li>Domain</li> </ul>"},{"location":"riddl/concepts/application/#contains","title":"Contains","text":"<ul> <li>Type</li> <li>Group</li> <li>Handler</li> </ul>"},{"location":"riddl/concepts/author/","title":"Author","text":"<p>An author definition merely describes one of the authors that wrote the  encapsulating definition. An author definition contains the usual profile  information for a human including: * full name * email address * name of an organization (optional) * title at that organization (optional) * url for more information (optional)</p>"},{"location":"riddl/concepts/author/#occurs-in","title":"Occurs In","text":"<p>All vital definitions</p>"},{"location":"riddl/concepts/author/#contains","title":"Contains","text":"<p>No other definitions</p>"},{"location":"riddl/concepts/case/","title":"Story Case","text":"<p>Stories are specified with multiple <code>case</code> definitions that it contains. A  case in this context is a use case, that is, a set of steps that define  the interaction between components. Multiple cases are often needed to  show both happy and unhappy paths.</p> <p>A case is composed of a set of steps. Those steps consist of a described  relationship between two components. These can be general (any component to  any component) or specific for certain pairs of components. </p> <p>The following table shows the pairings recognized:</p> keyword From To Description arbitrary any any Arbitrary relationship between components tell any entity Send a message to an entity asynchronously publish any pipe Publish a message to a pipe subscribe any pipe Subscribe to a pipe saga any saga Initiate a saga select user element Select an item from application element provide user element Provide input data too application present user element Cause an application to present info"},{"location":"riddl/concepts/case/#occurs-in","title":"Occurs In","text":"<ul> <li>Epic</li> <li>Use Case</li> </ul>"},{"location":"riddl/concepts/case/#contains","title":"Contains)","text":"<ul> <li>Statements</li> </ul>"},{"location":"riddl/concepts/comment/","title":"Comment","text":"<p>A comment is a semantic component of the RIDDL language and not just ignored by the parser. Comments use the C language notation, for example: <pre><code>// This is a comment to the end of the line -------&gt;\n/* This is an inline comment with a terminator: */\n</code></pre> However, comments cannot just occur anywhere white space may occur. They can occur at the top level of a file, before definitions and after definitions. </p>"},{"location":"riddl/concepts/conditional/","title":"Condition","text":"<p>A condition is a logical (boolean) expression resulting in true or false.</p>"},{"location":"riddl/concepts/conditional/#arbitrary-conditional-arbitrary","title":"Arbitrary Conditional (#arbitrary)","text":"<ul> <li>just a string</li> </ul>"},{"location":"riddl/concepts/conditional/#numeric-expressions-numeric","title":"Numeric Expressions (#numeric)","text":"<p>TBD</p>"},{"location":"riddl/concepts/conditional/#condition","title":"Conditions (Boolean Expressions)","text":"<p>TBD</p>"},{"location":"riddl/concepts/conditional/#occurs-in","title":"Occurs In","text":"<ul> <li>Statements</li> </ul>"},{"location":"riddl/concepts/conditional/#contains","title":"Contains","text":"<p>Nothing</p>"},{"location":"riddl/concepts/connector/","title":"Connector","text":"<p>Connectors are uni-directional conduits for reliably transmitting data of a particular type.</p>"},{"location":"riddl/concepts/connector/#data-transmission-type","title":"Data Transmission Type","text":"<p>Pipes can transmit any data type that RIDDL can specify. There is only one data type that flows in a pipe.  The transmission type is often used with an alternation of messages such as the commands and queries that an entity might receive.</p>"},{"location":"riddl/concepts/connector/#pipe-end-connections","title":"Pipe End Connections","text":"<p>Pipes have two ends, <code>from</code> and <code>to</code>, and each must be connected to a  processor. Data elements of the transmission  type flow from <code>from</code> to <code>end</code>. Such end connections may be closed or  open. A closed end is specified in the definition of the pipe by  connecting it to an inlet (for <code>to</code> ends) or  outlet (for <code>from</code> ends). An open end is not specified in the pipe definition. Instead, it is  implied by use of the<code>publish</code> and <code>subscribe</code> statementss. This permits multiple publishers and multiple subscribers. </p>"},{"location":"riddl/concepts/connector/#pipe-options","title":"Pipe Options","text":"<p>Pipes may play a large role in the resiliency of a reactive system, so we  permit a variety of options to be specified on them. These options are  only intended as advice to the translators converting the pipe into something  else. For example, a pipe may or may not need to be persistent. If a pipe has the burden of persistence removed, it is likely much more performant because  the latency of storage is not involved.</p>"},{"location":"riddl/concepts/connector/#persistent","title":"<code>persistent</code>","text":"<p>The messages flowing through the pipe are persisted to stable, durable storage, so they cannot be lost even in the event of system failure or shutdown. This arranges for a kind of  bulkhead  in the system that retains published data despite failures on either end of the pipe</p>"},{"location":"riddl/concepts/connector/#commitable","title":"<code>commitable</code>","text":"<p>With this option, pipes support the notion of being commitable. This means the consuming processors of a pipe's data may commit to the pipe that they have completed their work on one or more data items. The pipe then guarantees that it will never transmit those data items to that processor again. This is helpful when the processor is starting up to know where it left off from its previous incarnation.</p>"},{"location":"riddl/concepts/connector/#partitionsn","title":"<code>partitions(n)</code>","text":"<p>For scale purposes, a pipe must be able to partition the data by some data value that is in each data item (a key) and assign the consumption of the data to corresponding members of a consumer group. This permits multiple instances of a consuming processor to handle the data in parallel. The <code>n</code> value is the minimum recommended number of partitions which defaults to 5 if not specified</p>"},{"location":"riddl/concepts/connector/#lossy","title":"<code>lossy</code>","text":"<p>By default, pipes provide the guarantee that they will deliver each data item at least once. The implementation must then arrange for data items to be  idempotent so that the effect of running the event two or more times is the same as running it once. To counteract this assumption a pipe can be use the <code>lossy</code> option which reduces the guarantee to merely best reasonable effort, which could mean loss of data. This may increase throughput and lower overhead and is warranted in situations where data loss is not catastrophic to the system. For example, some IoT systems permit this kind of data loss because  the next transmission is imminent.</p>"},{"location":"riddl/concepts/connector/#producers-consumers","title":"Producers &amp; Consumers","text":"<p>Attached to the ends of pipes are producers and consumers. These are processors of data and may originate,  terminate or flow data through them, connecting two pipes together. Producers provide the data, consumers consume the data. Sometimes we call producers sources because they originate the data. Sometimes we call consumers sinks because they terminate the data.</p> <p>{{&lt; mermaid align=\"left\" &gt;}} graph LR; Producers \u2192 P{{Pipe}} \u2192 Consumers Source \u2192 P1{{Pipe 1}} \u2192 Flow \u2192 P2{{Pipe 2}} \u2192 Sink {{&lt; /mermaid &gt;}}</p> <p>Pipes may have multiple publishers (writers of data to the pipe) and multiple consumers (readers of data from the pipe). In fact, because of the partitioned consumption principle, there can be multiple groups of consumers, each group getting each data item from the pipe.</p>"},{"location":"riddl/concepts/connector/#subscriptions","title":"Subscriptions","text":"<p>{{&lt; hint type=warning icon=gdoc_dangerous title=\"Not Implemented\" &gt;}} This feature is not implemented as of 0.16.1 {{&lt; /hint &gt;}}</p> <p>When a pipe has multiple consumers, they are organized into subscriptions.  Each subscription gets every datum the pipe carries. Consumers attach to a subscription and there is generally one consumer per partition of the  subscription. Sometimes subscriptions are known as consumer groups as is the case for Kafka.</p>"},{"location":"riddl/concepts/connector/#occurs-in","title":"Occurs In","text":"<ul> <li>Streamlets</li> </ul>"},{"location":"riddl/concepts/connector/#contains","title":"Contains","text":"<p>Nothing</p>"},{"location":"riddl/concepts/constant/","title":"Constant","text":"<p>A constant is simply a definition that names an unchanging value. This is useful for modeling technical domains that utilize constant values</p>"},{"location":"riddl/concepts/constant/#occurs-in","title":"Occurs In","text":"<p>All vital definitions may contain constants.</p> <ul> <li>Adaptors,</li> <li>Applications,</li> <li>Contexts,</li> <li>Domains,</li> <li>Functions,</li> <li>Entities,</li> <li>Epic.</li> <li>Processors,</li> <li>Projectors,</li> <li>Repositories</li> <li>Sagas, and</li> </ul>"},{"location":"riddl/concepts/constant/#contains","title":"Contains","text":"<p>Nothing</p>"},{"location":"riddl/concepts/context/","title":"Context","text":"<p>A <code>context</code> definition in RIDDL represents the notion of a  bounded context  from  Domain Driven Design (DDD). A bounded context is an isolated portion of some knowledge domain.  Consequently, in RIDDL we defined a <code>context</code>  inside a <code>domain</code>.</p> <p>DDD uses bounded contexts to divide complexity in large knowledge domains into manageable portions. Since large knowledge domains are difficult for a  single human to comprehend in its entirety, DDD uses bounded contexts as a  primary structuring tool. Bounded contexts must be able to be fully comprehended by any individual person. RIDDL utilizes both of these concepts the way DDD  intends.  </p> <p>Since bounded contexts are also subdomains, we distinguish them from  subdomains with a few characteristics as discussed below.</p> <p>As the name suggests, a <code>context</code> has a finite and precise definitional boundary. That means that it can be implemented easily because there is no vagueness. A bounded context defines its boundary via a  ubiquitous language that facilitates a common comprehension of the context between humans. Indeed,  this is one of its primary reasons for its existence: to assist in eliminating the confusion and miscommunication of imprecisely defined concepts that human languages tend to produce, even within a single language. For example, consider the English word \"order\" in various contexts:</p> <ul> <li>restaurant - a list of food items to be made and delivered to a table</li> <li>backoffice - a list of things to be received from a shipper</li> <li>politics - a state of peace, freedom from unruly behavior, and respect for law</li> <li>mathematics - a sequence or arrangement of successive things.</li> <li>sociology - a group of people united in a formal way</li> <li>society - a rank, class, or special group in a community or society</li> <li>architecture -  a type of column and entablature forming the unit of a style</li> <li>economics - a written direction to pay money to someone</li> <li>military - a directive or command from a superior to a subordinate</li> </ul> <p>And that's just the confusion resulting from one common business word!</p> <p>A context's ubiquitous language arises from the named definitions it contains.  The names are specific terms used with precision by the subject-matter (knowledge domain) expert. Other practitioners (designers, developers, testers)  must use these terms so that the language truly is ubiquitous and everyone is  on the same page. </p> <p>When modelling a system with RIDDL, the ubiquitous language boils down to the names of the definitions that RIDDL permits inside a <code>context</code> definition, as shown in the list below. You can correctly think of a <code>context</code>s ubiquitous language as the interface to that knowledge domain. It is very analogous to an API (Application Programming Interface) as the interface to a program. The API</p> <p>To further your understanding, watch this  34-minute video by Eric Evans  from DDD Europe 2020 conference</p>"},{"location":"riddl/concepts/context/#occurs-in","title":"Occurs In","text":"<ul> <li>Domains</li> </ul>"},{"location":"riddl/concepts/context/#contains","title":"Contains","text":"<ul> <li>Adaptors</li> <li>Authors</li> <li>Entities</li> <li>Functions</li> <li>Handlers</li> <li>Includes</li> <li>Processors</li> <li>Projectors</li> <li>Sagas</li> <li>Terms</li> <li>Types</li> </ul>"},{"location":"riddl/concepts/definition/","title":"Definition","text":"<p>RIDDL is a declarative language, in that it declares the definition of  certain concrete concepts in a hierarchical fashion. The notion of a  definition is abstract since there are many types of definitions,  all described in this concepts section. Succinctly, a definition is  anything that has a name unique amongst its peers.   </p>"},{"location":"riddl/concepts/definition/#common-attributes","title":"Common Attributes","text":"<p>All definitions have some common attributes:</p> <ul> <li>loc: The location of the definition in its input file. (line &amp; column)</li> <li>id: The name, or identifier, of the definition.</li> <li>metadata: Non-definitional meta data that help comprehend it</li> <li>briefly: A string to briefly describe the definition. These are used in   the documentation output and the glossary.</li> <li>description: A block of   Markdown that   fully describes the definition. All the facilities provided by the hugo-geekdoc template for hugo are supported.</li> </ul> <p>These attributes merely provide supplemental information about the definition but are not part of the definition.</p>"},{"location":"riddl/concepts/definition/#vital-definitions","title":"Vital Definitions","text":"<p>The vital definitions share a set of attributes that, like the Common Attributes, are informational rather than definitional. </p>"},{"location":"riddl/concepts/description/","title":"Description","text":"<p>Descriptions describe definitions. You can add a description to any kind of definition. Descriptions are written in Markdown format and can include any of the capabilities provided by the GeekDoc hugo formatter including mermaid  based diagrams. Descriptions can also be provided in separate files and via public (no password required) HTTP URLs. </p>"},{"location":"riddl/concepts/description/#occurs-on","title":"Occurs On","text":"<p>Every kind of definition.</p>"},{"location":"riddl/concepts/description/#contains","title":"Contains","text":"<p>Markdown text either directly in RIDDL, in a file, or via a URL.</p>"},{"location":"riddl/concepts/domain/","title":"Domain","text":"<p>A domain is the top-most definitional level in RIDDL. We use the word  domain in the sense of a knowledge domain; like an entire business, a  field of study, or some portion of these. It has nothing to do with Internet  domain names. A domain is an arbitrary boundary around some subset of concepts in the universe. As with Domain Driven Design, RIDDL uses the concept of a domain to group together a set of related concepts.</p> <p>Domains in RIDDL are inert. That is they only serve to contain definitions  that do things, but they don't do things themselves.</p> <p>Domains can recursively contain other nested domains so that a hierarchy of  domains and subdomains is established.  Because of this, we can organize any large, complex knowledge domain or field of study, into an hierarchical ontology.</p> <p>For example, if you were modelling the domain of Two Wheeled Vehicles you might devise a domain hierarchy like this: * Two Wheeled Vehicle     - Motorized       - ICE powered motorcycles       - Scooter       - Electric Bicycles       - Segway    * UnMotorized     * Bicycles     * Oxcart     * Handtruck     * Human With Training Wheels</p>"},{"location":"riddl/concepts/domain/#occurs-in","title":"Occurs In","text":"<ul> <li>Root</li> <li>Domains {{&lt; icon \"rotate-left - domains   can be nested in a super-domain.</li> </ul>"},{"location":"riddl/concepts/domain/#contains","title":"Contains","text":"<p>Within a domain, you can define these things:</p> <ul> <li>Actors - someone or thing that uses the domain</li> <li>Applications - an user interface  </li> <li>Authors - who defined the domain</li> <li>Contexts - a precisely defined bounded context within the domain</li> <li>Domains :fontawesome-regular-rotate-left: - domains    can have nested domains (subdomains)</li> <li>Epics - a story about external entities   interacting with the domain</li> <li>Includes - inclusion of entity content from a   file</li> <li>Options - optional declarations about a    definition</li> <li>Terms - definition of a term relevant to the   domain</li> <li>Types - information definitions used throughout   the domain</li> </ul>"},{"location":"riddl/concepts/element/","title":"Application Element","text":"<p>Elements are the definitions that define the user interface for an application. Every element is associated  with a data type for either input or output.  Users are either sending information to inputs or receiving information from outputs. </p>"},{"location":"riddl/concepts/element/#element-types","title":"Element Types","text":"<p>There is one RIDDL definition for each of the four typical categories of  User Interface elements<sup>1</sup> as shown in the table below</p>"},{"location":"riddl/concepts/element/#group","title":"Group","text":"<p>TBD</p> UI Element RIDDL Description Input Give input of data items to fill an aggregate Input Select select item(s) from a list Output View presents a data value for consideration Navigation Activate cause the application to change its context Container Group groups elements together"},{"location":"riddl/concepts/element/#activate","title":"Activate","text":"<p>An Activate definition instructs the application to change context to a  different group of elements.</p>"},{"location":"riddl/concepts/element/#occurs-in","title":"Occurs In","text":"<ul> <li>Context</li> </ul>"},{"location":"riddl/concepts/element/#contains","title":"Contains","text":"<ul> <li>Elements</li> <li>Handlers</li> </ul> <ol> <li> <p>See Critical UI Elements of Remarkable Interfaces \u21a9</p> </li> </ol>"},{"location":"riddl/concepts/entity/","title":"Entity","text":"<p>An entity in RIDDL is the same as it is in DDD which defines it this way: {{% hint tip  %}} Entity Definitions</p> <p>An object primarily defined by its identity is called an Entity.</p> <p>and</p> <p>Many objects are not fundamentally defined by their attributes, but rather by a thread of continuity and identity. {{% /hint %}}</p> <p>There are three main aspects to this definition of entity: * Entities in the software implementation of the model are objects,    containing both state and function. They can both be and do.   This means they can represent any physical object, a concept, etc.  * Entities have an identity;  they are identified by some unique value   that no other entity of the same type may have. * Entities are continuous; they have a lifecycle, evolving from creation,   through their useful lifespan, to destruction.</p> <p>An entity is the fundamental processor of work in a reactive system and in a RIDDL model. Entities are most often implemented in software using one of  these techniques: * using the user model where actors process messages and encapsulate state. * object-oriented programming which also encapsulate states and defines    functions to manipulate that state.  * functional programming where a collection of functions process messages or    function calls using exclusive access to some data and a queue of messages;   this simulates the user model.  </p>"},{"location":"riddl/concepts/entity/#identity","title":"Identity","text":"<p>Entities have a unique immutable persistent identifier, much like people have  names except our personal names are not unique. The unique identifier is  used to locate the entity in a computing system and for other computing  purposes. These immutable and unique identifiers convey equivalence. That  is when two values of an identifier are the same, then by definition, they must refer to the same entity.  Changing the state of the entity does not  break this equivalence. Type <code>Id</code>,  which provides the means to reference the entity in its context or between contexts. An Entity's immutable identity conveys equivalence. Individual pieces of data of an entity can change their values (mutable).</p>"},{"location":"riddl/concepts/entity/#equality","title":"Equality","text":"<p>Entities hold state, whether that state is persistent or not. However, for entities, the most important state value is the unique identifier for that entity. Consider this diagram:</p>   ![Entity Equivalence](/images/entities.png \"Entity Equivalence\")   <p>Two instances of the same Entity may have different attribute values, but because both instances have the same identity value, they represent the same Entity. The identifier \"John Smith\" is used in two entities that differ in their state. By definition, this means they refer to the same entity.  However, when you compare \"John Smith\" with \"Jane Smith\", they are not the same entity, even if all their other attributes are the same.</p>"},{"location":"riddl/concepts/entity/#options","title":"Options","text":"<p>Entities can have various optional characteristics as shown in the sections  below</p>"},{"location":"riddl/concepts/entity/#technology","title":"technology","text":"<p>Arguments: Multiple, a list of the names of technologies intended to be  used in the implementation. Implication: This does not impact the behavior of the entity except in the  differences provided by various implementation technologies. </p>"},{"location":"riddl/concepts/entity/#event-sourced","title":"event sourced","text":"<p>Arguments: None Implication: The entity should use event sourcing to store its state as a  log of change events</p>"},{"location":"riddl/concepts/entity/#value","title":"value","text":"<ul> <li>Arguments: None</li> <li>Implication: The entity should store only its latest value without using    event sourcing.</li> </ul>"},{"location":"riddl/concepts/entity/#transient","title":"transient","text":"<ul> <li>Arguments: None</li> <li>Implication: The entity should not persist its state at all and is only   available in transient memory. All entity values will be lost when the    service is stopped.</li> </ul>"},{"location":"riddl/concepts/entity/#aggregate","title":"aggregate","text":"<ul> <li>Arguments: None</li> <li>Implication: The entity is an aggregate root entity through which all    commands and queries are sent on behalf of the aggregated entities.</li> </ul>"},{"location":"riddl/concepts/entity/#consistent","title":"consistent","text":"<ul> <li>Arguments: None</li> <li>Implication: The entity's implementation should favor consistency over   availability in Erik Brewer's CAP theorem.</li> </ul>"},{"location":"riddl/concepts/entity/#available","title":"available","text":"<ul> <li>Arguments: None</li> <li>Implication: The entity's implementation should favor availability over    consistence in Erik Brewer's CAP theorem. </li> </ul>"},{"location":"riddl/concepts/entity/#finite-state-machine","title":"finite state machine","text":"<ul> <li>Arguments: None</li> <li>Implications: The entity is intended to implement a finite state machine.</li> </ul>"},{"location":"riddl/concepts/entity/#message-queue","title":"message queue","text":"<ul> <li>Arguments: None</li> <li>Implications: The entity should allow receipt of commands and queries via a   message queue.</li> </ul>"},{"location":"riddl/concepts/entity/#kind","title":"kind","text":"<ul> <li>Arguments: one string indicating the kind of entity</li> <li>Implications: The general kind of entity being defined. This option takes a   single value which provides the kind of entity.  Examples of useful kinds    are \"device\", \"user\", \"concept\", \"machine\". This entity option may be used   by downstream AST processors, especially code generators. Downstream processors may   require additional entity kind values.</li> </ul>"},{"location":"riddl/concepts/entity/#occurs-in","title":"Occurs In","text":"<ul> <li>Contexts</li> </ul>"},{"location":"riddl/concepts/entity/#contains","title":"Contains","text":"<ul> <li>Authors - define who the authors of the   entity are</li> <li>Functions - named definitions of processing</li> <li>Handler - how to handle messages sent to an   entity</li> <li>Includes - inclusion of entity content from a    file</li> <li>Invariants - logical expressions that must   always hold true</li> <li>Options - define translation options for the   entity</li> <li>State - the data an entity holds</li> <li>Types - the definition of a type of information</li> <li>Terms - the definition of a term related to    the entity</li> </ul>"},{"location":"riddl/concepts/epic/","title":"Epics","text":"<p>An epic in RIDDL is a definition that defines a large user story with a set  of use cases.  This is the same  concept as the idea  Kent Beck introduced in 1997. In  RIDDL, a story gets a little more involved than the  usual formulations  of a user story:</p> <p>As an {user}, I would like {capability}, so that {benefit}</p> <p>or</p> <p>In order to receive {benefit}, as an {user}, I can {capability}</p> <p>which have these three ideas: * An <code>user</code> that provides the role played by the narrator of the story * A <code>capability</code> that provides the capability used by the narrator * A <code>benefit</code> that provides the reason why the narrator wants to    use the <code>capability</code></p> <p>A RIDDL Epic also provides a set of use cases that relate the story to other RIDDL components through the steps taken for each [<code>case</code>](case.md. Each case specifies a set of <code>interactions</code> that define and label the interactions between other RIDDL definitions such as elements, entities, and projectors. Cases can also outline user acceptance testing.</p> <p>Stories are designed to produce sequence diagrams. This allows the intended interaction of some user (human or not) with the system being designed in RIDDL to support a detailed definition of a user story.</p>"},{"location":"riddl/concepts/epic/#occurs-in","title":"Occurs In","text":"<ul> <li>Domains</li> </ul>"},{"location":"riddl/concepts/epic/#contains","title":"Contains)","text":"<ul> <li>Cases</li> </ul>"},{"location":"riddl/concepts/field/","title":"Field","text":"<p>Fields are the unit of composition of an aggregate type, state, or  projection. A field is a simple mapping of a name to a type. For example:</p> <p><code>name: Number</code></p> <p>specifies that the field named <code>name</code> has type <code>Number</code>. Fields are most often referenced in conditionals to supply  the values over which truthiness is computed. </p>"},{"location":"riddl/concepts/field/#occurs-in","title":"Occurs In","text":"<ul> <li>Types </li> <li>States</li> <li>Projectors</li> </ul>"},{"location":"riddl/concepts/field/#contains","title":"Contains","text":"<p>Nothing</p>"},{"location":"riddl/concepts/function/","title":"Function","text":"<p>A function definition provides a way to not repeat yourself in  other definitions. We can define functions in several places and then use  them in an expression or action. This way, we only need to define the logic  for something once.</p>"},{"location":"riddl/concepts/function/#occurs-in","title":"Occurs In","text":"<ul> <li>Contexts</li> <li>Entities</li> <li>Handlers</li> </ul>"},{"location":"riddl/concepts/function/#contains","title":"Contains","text":"<ul> <li>Fields</li> <li>Statements</li> <li>Functions :fontawesome-regular-rotate-left:</li> </ul>"},{"location":"riddl/concepts/group/","title":"Group","text":"<p>A group is the abstract structuring concept for an application. Groups can be  nested which allows them to form a hierarchy that defines the structure of a  user interface. Each group can also contain UI elements such as  inputs and outputs as well as types. To make this more tangible, groups could be used to model the following  implementation concepts: * HTML forms, pages, containers, and sections * mobile application screens, pages, forms and containers * accordions (vertically stacked list of items with show/hide functionality)</p> <p>A UI designer is free to arrange the contained elements in any fashion, but presumably in a way that is consistent with their overall UI design theme.</p>"},{"location":"riddl/concepts/group/#occurs-in","title":"Occurs In","text":"<ul> <li>Application</li> <li>Group</li> </ul>"},{"location":"riddl/concepts/group/#contains","title":"Contains","text":"<ul> <li>Group {{&lt; icon \"rotate-left</li> <li>Type</li> <li>Input</li> <li>Output</li> </ul>"},{"location":"riddl/concepts/handler/","title":"Handlers","text":"<p>A handler is a very important definition in RIDDL because it is RIDDL's  way of expressing both business logic and relationships between the various components in a model. Handlers do that by specifying what should be done  whenever a message of a particular type is received by its parent definition. Handlers are composed as a set of on clauses that connect a message with a set of statements. The statements provide the business  logic that should be executed upon receipt of the message. Because that business  logic can send and publish further messages to other components, a  relationship can be inferred between the component receiving the message  and the component that contains the handler.</p> <p>There are several kinds of handlers depending on the handler's containing definition, as shown in this table:</p> Occurs In Handler Focus Adaptor Translate messages between contexts Application Handling the messages received from the user Context Implements API of the stateless context Entity Handler to use on new entity before any morph action Processor Provide ETL logic for moving inputs to outputs Projection Handle updates and queries on the projection Repository Handle updates and queries on the repository State Handle messages while entity is in that state <p>The types of definition in which Handlers occur are known as the  \"active\" definitions. More details are provided in the sections below. </p>"},{"location":"riddl/concepts/handler/#adaptor-handlers","title":"Adaptor Handlers","text":"<p>Adaptor handlers provide the translation of messages from  context to another.</p>"},{"location":"riddl/concepts/handler/#application-handlers","title":"Application Handlers","text":"<p>Application handlers process the events generated by the Application's user  to invoke business logic that typically results in sending further messages  to the \"back end\" (typically a gateway context). This allows the  application to be connected to the rest of the model. </p>"},{"location":"riddl/concepts/handler/#context-handlers","title":"Context Handlers","text":"<p>Context handlers imply a stateless API for the context, perhaps  encapsulating the other things defined within the  context.</p>"},{"location":"riddl/concepts/handler/#entity-handlers","title":"Entity Handlers","text":"<p>Entity handlers specify the default or \"catch all\" handler for an entity. When the entity is new, or is not in a specific state, this default handler  is used to process each message. If the message is not processed by the handler, then the entity's processing for that message is null (message ignored). When an entity is in a specified state, it processes messages defined by  the handler within that state (see below).</p>"},{"location":"riddl/concepts/handler/#projection-handler","title":"Projection Handler","text":"<p>Projections provide </p>"},{"location":"riddl/concepts/handler/#state-handler","title":"State Handler","text":"<p>State handlers process messages while an entity is in that specific  state, presumably with the intent of updating that state by generating  events from commands.</p>"},{"location":"riddl/concepts/handler/#occurs-in","title":"Occurs In","text":"<ul> <li>Adaptors</li> <li>Applications</li> <li>Contexts</li> <li>Entities </li> <li>Processors</li> <li>Projectors</li> <li>Repositories</li> <li>State</li> </ul>"},{"location":"riddl/concepts/handler/#contains","title":"Contains","text":"<ul> <li>On Clauses - a specification of how to    handle an event</li> </ul>"},{"location":"riddl/concepts/include/","title":"Includes","text":"<p>Includes permit you to include content from a file into the definition in which it occurs. </p>"},{"location":"riddl/concepts/include/#occurs-in","title":"Occurs In","text":"<p>All vital definitions</p>"},{"location":"riddl/concepts/include/#contains","title":"Contains","text":"<p>Content relevant to the definition in which it is used. The input must conform to the hierarchy shown in the index</p>"},{"location":"riddl/concepts/inlet/","title":"Inlets","text":"<p>An Inlet is a component of a Processor that specifies a named input through  which data of a particular type streams into the processor. When an Inlet is  defined in an Entity, the entity acts only as  a <code>sink</code> processor.  </p>"},{"location":"riddl/concepts/inlet/#occurs-in","title":"Occurs In","text":"<ul> <li>Processors</li> <li>Entity</li> </ul>"},{"location":"riddl/concepts/inlet/#contains","title":"Contains","text":"<ul> <li>Type</li> </ul>"},{"location":"riddl/concepts/input/","title":"Input","text":"<p>An Input is the abstract notion of some information provided to an  application by its user (an user. To make this more tangible, inputs could be implemented as any of the following: * the submission of a typical htML form a user could fill in, * the tap of a button on a mobile device, * the selection of items from a list on a native application,  * a voice response providing information via any   IVR system, * a thought interpreted by a neural link, * a physical movement interpreted by a motion-detection device, * a retinal scan, * picking items from lists of information by looking and blinking * or any other system by which a human may provide information to a machine</p> <p>The nature of the implementation for an input is up to the UI Designer. RIDDL's concept of it is based on the net result: the data type received by the application. </p> <p>An input is a named component of an application  that receives data of a specific type from an user (user) of the application. Each input can define  data types and declares a  command message as the data received by the application's input.</p>"},{"location":"riddl/concepts/input/#occurs-in","title":"Occurs In","text":"<ul> <li>Group</li> </ul>"},{"location":"riddl/concepts/input/#contains","title":"Contains","text":"<ul> <li>Type</li> <li>Message</li> </ul>"},{"location":"riddl/concepts/interaction/","title":"Interaction","text":"<p>An interaction defines the relationship between two things in the context of  an Use Case. </p>"},{"location":"riddl/concepts/interaction/#occurs-in","title":"Occurs In","text":"<ul> <li>Use Case</li> </ul>"},{"location":"riddl/concepts/interaction/#contains","title":"Contains","text":"<p>Nothing</p>"},{"location":"riddl/concepts/invariant/","title":"Invariants","text":"<p>An invariant is a logical expression that must always hold true. They can  be used to validate state changes in entities, or parameter values in  functions.</p>"},{"location":"riddl/concepts/invariant/#occurs-in","title":"Occurs In","text":"<ul> <li>Entities - specifies a rule on the state of an    entity</li> <li>Functions - specifies a rule on the input    parameters of a function</li> </ul>"},{"location":"riddl/concepts/invariant/#contains","title":"Contains","text":"<p>Nothing</p>"},{"location":"riddl/concepts/message/","title":"Messages","text":"<p>Messages are a foundational concept in RIDDL because a RIDDL model implies  an implementation that is a message-driven system per the  Reactive Manifesto. Messages in RIDDL are  a special case of an aggregate type  and the lingua franca of many RIDDL definitions. They define the API for all the processors: * <code>adaptor</code>s * <code>application</code>s * <code>context</code>s * <code>entity</code>s * <code>processor</code>s * <code>projector</code>s * and <code>repository</code>s</p> <ul> <li>That is, these are the fundamental building blocks of a message-driven system</li> </ul>"},{"location":"riddl/concepts/message/#differences-between-kinds-of-messages","title":"Differences Between Kinds of Messages","text":"<p>RIDDL follows Bertrand Meyer's notion of command/query separation which states, in the context of object-oriented programming in Eiffel that:</p> <p>every method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, asking a question should not change the answer.<sup>1</sup></p> <p>Consequently, RIDDL adheres to this principal and employs the notion in message definitions since RIDDL is message-oriented not object-oriented. However,  RIDDL also includes message types for the responses from commands and  queries, events and results, respectively. The following subsections provide  definitions of these four things</p>"},{"location":"riddl/concepts/message/#command","title":"Command","text":"<p>A directive to perform an action, likely resulting in a change to some  information.</p>"},{"location":"riddl/concepts/message/#event","title":"Event","text":"<p>A recordable fact resulting from a change to some information.</p>"},{"location":"riddl/concepts/message/#query","title":"Query","text":"<p>A request for information from something</p>"},{"location":"riddl/concepts/message/#result","title":"Result","text":"<p>A response to a query containing the information sought. </p>"},{"location":"riddl/concepts/message/#summary","title":"Summary","text":"<p>The various characteristics of the four kinds of messages are shown in the  table below.</p> Kind Request? Response? Cancellable? Relationship Command Yes No Yes Independent Event Maybe Yes No Consequent Of Command Query Yes No Yes Independent Result No Yes No Consequent Of Query <p>The truth table above helps you understand the relationship between the kind of message and how it is handled by a model component. The sections below get  even more specific.</p>"},{"location":"riddl/concepts/message/#how-messages-are-handled-by-adaptors","title":"How Messages Are Handled By Adaptors","text":"Kind In Regard To Handling By Adaptor Command Intent To Translate For Context Event Intent To Translate For Context Query Intent to Translate For Context Result Intent to Translate For Context"},{"location":"riddl/concepts/message/#how-messages-are-handled-by-applications","title":"How Messages Are Handled By Applications","text":"Kind In Regard To Handling By Application Command Data given from user to application Event Not Applicable Query Not Applicable Result Data provided to user from application"},{"location":"riddl/concepts/message/#how-messages-are-handled-by-contexts","title":"How Messages Are Handled By Contexts","text":"Kind In Regard To Handling By Context Command Intent To Take Some Stateless Action Event Notification That a Command Completed Query Intent to Read From The Context Result Result Of Reading From Context"},{"location":"riddl/concepts/message/#how-messages-are-handled-by-entities","title":"How Messages Are Handled By Entities","text":"Kind In Regard To Handling By  Entity Command Intent To Modify Entity State Event Entity State Was Changed Query Intent To Read Entity state Result Consequent Of Query"},{"location":"riddl/concepts/message/#how-messages-are-handled-by-processors","title":"How Messages Are Handled By Processors","text":"Kind In Regard To Handling By Processor Command Intent To Update Projection State Event The Projection's State Was Modified Query Intent to Read Projection State Result Result Of Reading Projection State"},{"location":"riddl/concepts/message/#how-messages-are-handled-by-projections","title":"How Messages Are Handled By Projections","text":"Kind In Regard To Handling By Projection Command Intent To Update Projection State Event The Projection's State Was Modified Query Intent to Read Projection State Result Result Of Reading Projection State"},{"location":"riddl/concepts/message/#occurs-in","title":"Occurs In","text":"<p>All Vital Definitions</p>"},{"location":"riddl/concepts/message/#contains","title":"Contains","text":"<p>Fields</p> <ol> <li> <p>Meyer, Bertrand. \"Eiffel: a language for software engineering\". p. 22\u00a0\u21a9</p> </li> </ol>"},{"location":"riddl/concepts/metadata/","title":"Meta Data","text":"<p>Coming Soon.</p>"},{"location":"riddl/concepts/onclause/","title":"On Clause","text":"<p>An On Clause specifies how to handle a particular kind of message or situation as part of the definition of a handler.  An On Clause is associated with a specific message definition and contains  statements that define the handling of that  message by the handler's parent. The containing Processor is the receipient of the message and the sender of any statements that send messages.</p> <p>There are fours kinds of On Clauses: * Initialization - when the definition is created and initialized * Termination - when the definition is terminated  * Message - when the definition receives a specific kind of message * Other - whenthe definition receives a message not otherwise handled</p>"},{"location":"riddl/concepts/onclause/#occurs-in","title":"Occurs In","text":"<ul> <li>Handlers - the handler to which the On    clause is applied</li> </ul>"},{"location":"riddl/concepts/onclause/#contains","title":"Contains","text":"<ul> <li>Statement - specifies what should happen    when the event occurs</li> </ul>"},{"location":"riddl/concepts/option/","title":"Options","text":"<p>Options are instructions to translators on how a particular  definition should be regarded. Any translator can make use of any option. Options can take a list of string arguments much like the  options and arguments to a program. If none are specified, the option is  considered to be a Boolean value that is <code>true</code> if specified.</p> <p>Every vital definition in RIDDL allows a <code>technology</code> option that takes any number of string arguments. These can specify the technologies intended for the implementation. This idea was adapted from a similar idea in Simon Brown's C4 Model For Software Architecture</p> <p>Other options are specific to the kind of vital definition. See the  vital definition's page for details on the options they take. Non-vital  definitions do not allow options. </p>"},{"location":"riddl/concepts/option/#occurs-in","title":"Occurs In","text":"<p>All vital definitions</p>"},{"location":"riddl/concepts/option/#contains","title":"Contains","text":"<p>Option values which are simple identifiers with an optional set of string  arguments.</p>"},{"location":"riddl/concepts/outlet/","title":"Outlets","text":"<p>An Outlet is a component of a  Processor that specifies a named output through which data of a particular type streams out of the processor. When an Inlet is defined in an Entity, the entity acts only as a <code>source</code> processor, generating events.</p>"},{"location":"riddl/concepts/outlet/#occurs-in","title":"Occurs In","text":"<ul> <li>Processors</li> <li>Entity</li> </ul>"},{"location":"riddl/concepts/outlet/#contains","title":"Contains","text":"<ul> <li>Type</li> </ul>"},{"location":"riddl/concepts/output/","title":"Output","text":"<p>An Output definition is concerned with providing information to the user (an user) without regard to the form of that  information when presented to the user. To make this more tangible, an  Output could be implemented as any of the following:</p> <ul> <li>the text shown on a web page or mobile application</li> <li>the display of an interactive graphic, chart, etc. </li> <li>the presentation of a video or audio recording</li> <li>haptic, olfactory or gustatory feedback</li> <li>any other way in which a human can receive information from a machine.</li> </ul> <p>The nature of the implementation for an output is up to the UI Designer. RIDDL's concept of it is based on the net result: the data type received by the user.</p> <p>An Output is a named component of an application that sends data of a specific type from the  application to its user (an user) Each input can define data types and declares a result message as the data sent to the  user.</p>"},{"location":"riddl/concepts/output/#occurs-in","title":"Occurs In","text":"<ul> <li>Group</li> </ul>"},{"location":"riddl/concepts/output/#contains","title":"Contains","text":"<ul> <li>Type</li> <li>Message</li> </ul>"},{"location":"riddl/concepts/processor/","title":"Processors","text":"<p>A processor is a  vital definition that processes messages that it receives. There are many kinds of processors in RIDDL: * Adaptor</p> <p>some transformation of the data flowing in from its inlet, and produces different data to its outlet.</p>"},{"location":"riddl/concepts/processor/#inlets","title":"Inlets","text":"<p>An inlet provides the name and data type for an  input to the processor. There can be multiple inlets to the processor or none.  A processor with no inlets defined is called a source since it originates data by itself. </p>"},{"location":"riddl/concepts/processor/#outlets","title":"Outlets","text":"<p>An outlet provides the name and data type for an  output from the processor. There can be multiple outlets defined by the  processor or none. A processor with no outlets is called a sink since it  terminates data flow.</p>"},{"location":"riddl/concepts/processor/#kinds-of-processors","title":"Kinds Of Processors","text":"<p>RIDDL supports six kinds of processors. The kind of processor depends solely on the number of inlets and outlets that are defined by the processor, as  shown in the table:</p> # Inlets # Outlets Kind Description 0 any Source Sources originate their data, and publish it to an outlet any 0 Sink Sinks terminate their data, and consume it from their inlet 1 1 Flow Flows transform their data from inlet to outlet 1 any Split Splits their data from one inlet to multiple outlets any 1 Merge Merges their data from multiple intles to a single outlet any any Multi Any other combination is a many-to-many flow"},{"location":"riddl/concepts/processor/#handlers","title":"Handlers","text":"<p>A processor contains handlers that specify how the business logic should proceed. For sources, sinks, and flows, this is trivial. But for splits, merges and multis, there is a need to specify how the messages received on inlets are processed (transformed) and then put out to the outlets.</p>"},{"location":"riddl/concepts/processor/#occurs-in","title":"Occurs In","text":"<ul> <li>Contexts</li> </ul>"},{"location":"riddl/concepts/processor/#contains","title":"Contains","text":"<ul> <li>Inlets</li> <li>Outlets</li> <li>Handlers</li> </ul>"},{"location":"riddl/concepts/projector/","title":"Projectors","text":"<p>Projections get their name from Euclidean Geometry  but are probably more analogous to a  relational database view. The  concept is very simple in RIDDL: projections gather data from entities and  other sources, transform that data into a specific record type, and support querying that data arbitrarily.</p> <p>Projections transform update events from entities into a data set that can  be more easily queried. Projections have handlers that specify both how to apply updates to the projections state and satisfy queries against that state. A projection's data is always duplicate and not the system of record for the data. Typically persistent entities are the system of record for the data.</p>"},{"location":"riddl/concepts/projector/#occurs-in","title":"Occurs In","text":"<ul> <li>Contexts</li> </ul>"},{"location":"riddl/concepts/projector/#contains","title":"Contains","text":"<ul> <li>Authors</li> <li>Fields</li> <li>Handlers</li> <li>Includes</li> <li>Options</li> <li>Terms</li> </ul>"},{"location":"riddl/concepts/repository/","title":"Repository","text":"<p>A RIDDL repository is an abstraction for anything that can retain  information (e.g. messages) for retrieval at a later time. This might be a relational database, NoSQL database, a data lake,  an API, or something not yet invented. There is no specific technology implied other than the retention and retrieval of information. You should think of  repositories more like a message-oriented version of the  Java Repository Pattern than any particular kind of database. </p>"},{"location":"riddl/concepts/repository/#schemas","title":"Schemas","text":"<p>Repositories have traditionally had data schemas as part of their design  definition; but RIDDL regards schemas as a technical detail of the  implementation and leaves them unspecified. Repositories are only defined in  terms of their message handling.</p>"},{"location":"riddl/concepts/repository/#handling-messages","title":"Handling Messages","text":"<p>A repository has a handler that processes  messages with respect to the repository's stored information.</p> <p>Query messages sent to the repository  are requests for retrieval of some information. The handler should define  how the processing of that query should proceed and yield a  Result message.</p> <p>Command messages sent to the  repository are updates to the repository. The handler should define how the  update works and may optionally yield an Event message but generally that is  handled at a higher level of abstraction. </p>"},{"location":"riddl/concepts/repository/#occurs-in","title":"Occurs In","text":"<ul> <li>Context</li> </ul>"},{"location":"riddl/concepts/repository/#contains","title":"Contains","text":"<ul> <li>Types</li> <li>Messages</li> <li>Handler</li> </ul>"},{"location":"riddl/concepts/root/","title":"Root","text":"<p>The root concept refers to the container of domains. Domains are the top  level definition in RIDDL but because RIDDL is hierarchical, and you can have more than one domain definition at the top level, something has to contain those top level domains. We call that the root. A root is not a definition since it has no name. You can think of a root as the file in which a domain is defined.</p>"},{"location":"riddl/concepts/root/#occurs-in","title":"Occurs In","text":"<p>At the file root of the first file <code>riddlc</code> reads. </p>"},{"location":"riddl/concepts/root/#contains","title":"Contains","text":"<ul> <li>Domains</li> <li>Includes</li> </ul>"},{"location":"riddl/concepts/saga/","title":"Sagas","text":"<p>A Saga is a distributed persistent transaction that uses the Saga Pattern. Sagas are  used to coordinate state changes across multiple components (typically  entities) in a system. Every change (action) has a compensating action to  undo the action. This permits an organized rollback if one component cannot  proceed with the transaction.</p>"},{"location":"riddl/concepts/saga/#occurs-in","title":"Occurs In","text":"<ul> <li>Contexts</li> </ul>"},{"location":"riddl/concepts/saga/#contains","title":"Contains","text":"<ul> <li>SagaStep</li> </ul>"},{"location":"riddl/concepts/sagastep/","title":"Saga Steps","text":"<p>One step in a saga. Each step has input arguments and yields output. It also has both <code>do</code> and <code>undo</code> examples for its action and compensating action. </p>"},{"location":"riddl/concepts/sagastep/#occurs-in","title":"Occurs In","text":"<ul> <li>Contexts</li> </ul>"},{"location":"riddl/concepts/sagastep/#contains","title":"Contains","text":"<ul> <li>Statements</li> </ul>"},{"location":"riddl/concepts/state/","title":"States","text":"<p>A State defines the state of an entity. It is  defined as a set of fields with a  handler that defines  how messages cause changes to the value of those fields. </p> <p>An entity can have multiple state definitions with the implication that this entity would be considered a  Finite State Machine.  However, it would only be such if the entity used the  finite state machine option.</p>"},{"location":"riddl/concepts/state/#occurs-in","title":"Occurs In","text":"<ul> <li>Entities</li> </ul>"},{"location":"riddl/concepts/state/#contains","title":"Contains","text":"<ul> <li>Fields</li> <li>Handler</li> </ul>"},{"location":"riddl/concepts/statement/","title":"Statement","text":"<p>A Statement is an action that can be taken in response to a message. Statements  form the body of an on clause which is what  [handlers](handlers.md] are composed of. There are many  kinds of statements, described in the table below.</p> Name Description Arbitrary A textually described arbitrary statement Ask Send a message to an entity, asynchronously process result Become Instructs an entity change to a new handler Error Produce an error with a message ForEach Invoke statements on each item of a multi-valued field IfThenElse Evaluate a condition and choose execute a statement set FunctionCall Call a function to get a result Morph Morph the state of an entity to a new state Publish Publish a message to a pipe Reply Provide the reply message to the entity that invoked a query Return Return a value from a function Set Set a field value Tell Send a message to an entity directly, do not wait for result"},{"location":"riddl/concepts/statement/#level-of-detail","title":"Level of Detail","text":"<p>Statements are aimed at writing pseudocode in a structured but abstract way. RIDDL does not intend the system model to contain the code that will be used in its implementation. It also expects the reader to be intelligent and fill in the (obvious) gaps that are left missing. This leads to these objectives for writing an onclause's:</p> <ul> <li>Converting the specification to executable code should be done by a human or   a sufficiently capable AI/ML</li> <li>The statements are designed to capture interactions between the definitions   of the model, and are specifically not Turing complete.</li> <li>Statements should capture significant references to data and</li> <li>There is no need to model computational expresses exhaustively when a simple   natural language statement will do.</li> </ul>"},{"location":"riddl/concepts/statement/#applicability","title":"Applicability","text":"<p>Not all statements may be used in every On Clause. It depends on the kind of definition the statement is attached to. Statements occur in the onclause of the handlers of all the vital definitions. Note that the <code>Become</code> and <code>Morph</code> statements are only applicable to statements in an Entity. The others are generally applicable.</p>"},{"location":"riddl/concepts/statement/#occurs-in","title":"Occurs In","text":"<ul> <li>On Clause</li> </ul>"},{"location":"riddl/concepts/statement/#contains","title":"Contains","text":"<p>Some statements contain conditionals, values and path identifiers to reference things in the system models. None of these are definitions. </p>"},{"location":"riddl/concepts/streamlet/","title":"Streamlet","text":""},{"location":"riddl/concepts/term/","title":"Terms","text":"<p>A Term is merely a glossary entry. Since DDD requires bounded contexts to  have precise terminology, the Term definition allows model authors to include a word definition that is not a definition in the model. </p>"},{"location":"riddl/concepts/term/#occurs-in","title":"Occurs In","text":"<p>All vital definitions</p>"},{"location":"riddl/concepts/term/#contains","title":"Contains","text":"<p>Nothing</p>"},{"location":"riddl/concepts/type/","title":"Types","text":""},{"location":"riddl/concepts/type/#introduction","title":"Introduction","text":"<p>The RIDDL language allows users to define types of data, or information. RIDDL's type system is fairly rich, for a specification language, providing  abstractions for many concretely common information structures. This is done to make it easier for domain engineers and experts to understand the models they are creating. </p> <p>A type defines the shape of some information. There are many kinds of type definitions allowed, so we have grouped them into categories:</p> <p>{{&lt; toc &gt;}}</p>"},{"location":"riddl/concepts/type/#prefdefined","title":"Predefined Types","text":"<p>RIDDL supports several predefined types that just \"exist\" because they are: * applicable to nearly all fields of study or knowledge domains * fundamental in nature, covering the SI base units * fundamental in business, covering basic financial quantities such as currency * easily represented in any computing environment</p> <p>RIDDL inherently knows about these predefined types so to use them you just  use their name, no further definition is required. Here are the  simple predefined types:</p>"},{"location":"riddl/concepts/type/#simple","title":"Simple Predefined Types","text":"Name Description Abstract An unspecified, arbitrary type, compatible with any other type Nothing A type that cannot hold any value, commonly used as a placeholder Boolean A Boolean value, with values true or false Current An SI unit of electric current, measured in Amperes Date A date value comprising a day, month and year DateTime A combination of Date and Time Duration An amount of time, measured in SI units of seconds Length An SI unit of distance measured in meters Luminosity An SI unit of luminous intensity, measured in candelas Mass An SI unit of mass measured in kilograms Mole An SI unit of an amount of substance, measured in mol Number An arbitrary number, integer, decimal or floating point String A sequence of Unicode characters Temperature An SI unit of thermodynamic temperature, measured in Kelvin Time A time value comprising an hour, minute, second and millisecond TimeStamp A fixed point in time UUID A randomly unique identifier with low likeliness of collision"},{"location":"riddl/concepts/type/#parameterized","title":"Parameterized Predefined Types","text":"<p>Some predefined types take parameters to customize their content, we  call these parameterized predefined types.</p> Name Parameters Description String (<code>min</code>,<code>max</code>, <code>enc</code>) A String, as above, of a specific length range and encoding. Id (<code>entity</code>) A unique identifier for a kind of entity given by <code>entity</code> URL (<code>scheme</code>) A URL for a specific URL scheme (e.g. <code>http</code>) Range (<code>min</code>,<code>max</code>) A integer from <code>min</code> to <code>max</code> LatLong (<code>lat</code>, <code>long</code>) A location based on latitude and longitude Currency (<code>country-code</code>) The currency of a nation using ISO 3166 country codes Pattern (<code>regex</code>) A string value that conforms to a regular expression, <code>regex</code>"},{"location":"riddl/concepts/type/#compounds","title":"Compounds","text":"<p>Compound types add structure around the predefined types and require further definition in RIDDL.  </p>"},{"location":"riddl/concepts/type/#enumeration","title":"Enumeration","text":"<p>An enumeration defines a type that may take the value of one identifier from a closed set of constant identifiers using the <code>any</code> keyword and the set of identifiers enclosed in square brackets, like this: <pre><code>type Color = any of [Red, Orange, Yellow, Green, Blue, Indigo, Violet]\n</code></pre></p>"},{"location":"riddl/concepts/type/#alternation","title":"Alternation","text":"<p>A type can be defined as any one type chosen from a set of other type names using the <code>select</code> keyword followed by type names separated by <code>|</code>, like this:</p> <pre><code>type References = select String | URL\n</code></pre> <p>There must be at least two types in an alternation.</p>"},{"location":"riddl/concepts/type/#aggregation","title":"Aggregation","text":"<p>A type can be defined as an aggregate of a group of values of types. DDD calls this a \"value object\".  Aggregations can be nested, even recursively. Each value in the aggregation has an identifier (name) and a type separated by a colon. For example, here is the type definition for a rectangle located on a Cartesian coordinate system at point (x,y) with a given height and width: <pre><code>type Rectangle = { x: Number, y: Number, height: Number, width: Number }\n</code></pre></p>"},{"location":"riddl/concepts/type/#mapping","title":"Key/Value Mapping","text":"<p>A type can be defined as a mapping from one type (the key) to another type (the value). For example, here is a dictionary definition that maps a word (lower case letters) to a type named DictionaryEntry that presumably contains all the things one would find in a dictionary entry. <pre><code>type dictionary = mapping from Pattern(\"[a-z]+\") to DictionaryEntry\n</code></pre></p>"},{"location":"riddl/concepts/type/#messages","title":"Messages","text":"<p>An aggregate type (value object in DDD) can be declared to be one of four kinds of message types using the <code>command</code>, <code>event</code>, <code>query</code>, and <code>result</code> keywords. These type definitions are useful for sending messages to entities or across  streamlets. </p> <p>For example, here is a command definition: <pre><code>type JustDoIt = command { id: Id(AnEntity), encouragement: String, swoosh: URL }\n</code></pre></p>"},{"location":"riddl/concepts/type/#cardinality","title":"Cardinality","text":"<p>You can use a cardinality suffix or prefix with any of the type expressions  defined above to transform that type expression into the element type of  a collection.</p>"},{"location":"riddl/concepts/type/#suffixes","title":"Suffixes","text":"<p>The suffixes allowed are adopted from regular expression syntax with the  following meanings:</p> Suffix Meaning Required: exactly 1 instance of the preceding type <code>?</code> Optional: either 0 or 1 instances of the preceding type <code>*</code> Zero or more instances of the preceding type <code>+</code> One or more instances of the preceding type <code>...</code> One or more instances of the preceding type <code>...?</code> Zero or more instances of the preceding type <p>Note the empty first item in the table; without the suffix, the  cardinality of a type expression is \"required\" (exactly one). For example, in this: <pre><code>type MyType = { ids: Id+, name: String? }\n</code></pre> the <code>MyType</code> type is an aggregate that contains one or more Id values in the <code>ids</code> field and an optional string value in <code>name</code></p>"},{"location":"riddl/concepts/type/#prefixes","title":"Prefixes","text":"<p>The prefixes allowed have a similar meaning to the suffixes:</p> Prefix Meaning required Required: exactly 1 instance of the following type optional Optional: either 0 or 1 instances of the following type many Zero or more instances of the following type many required One or more instances of the following type"},{"location":"riddl/concepts/type/#occurs-in","title":"Occurs In","text":"<p>All Vital Definitions </p>"},{"location":"riddl/concepts/type/#contains","title":"Contains","text":"<ul> <li>Fields (in aggregations only)</li> </ul>"},{"location":"riddl/concepts/use-case/","title":"Use Case","text":"<p>A use case is a definition found in an epic that defines one way a user might interact with the system. </p>"},{"location":"riddl/concepts/user/","title":"User","text":"<p>An Actor is a participant in an Epic's Use Cases. The Actor's  identifier is typically the name of a representative real user of a system  and it is defined by identifying that person's role with respect to the system.</p>"},{"location":"riddl/concepts/user/#occurs-in","title":"Occurs In","text":"<ul> <li>Domains</li> </ul>"},{"location":"riddl/concepts/user/#contains","title":"Contains","text":"<p>Nothing (Leaf definition)</p>"},{"location":"riddl/concepts/value/","title":"Value","text":"<p>A value is an expression, in the context of a statement, that provides a value to a statement. There are a variety of value expressions but they are intentionally vague or abstract. The idea is that statements, values and conditions</p>"},{"location":"riddl/concepts/value/#occurs-in","title":"Occurs In","text":"<ul> <li>Statements</li> </ul>"},{"location":"riddl/concepts/value/#contains","title":"Contains","text":"<p>Values ae self-contained and only contain other values.</p>"},{"location":"riddl/concepts/vital/","title":"Vital Definitions","text":"<p>Not all definitions are equal. The RIDDL language considers some definitions to be more important than others, and we call these \"vital definitions\". You can recognize a vital definition because they all have Statements somewhere in their definitional hierarchy. Statements define behavior of a definition. Vital definitions are also the only ones permitted to reference an Author.</p> <p>These are the vital definitions: * Adaptors, * Applications, * Contexts, * Domains, * Functions, * Entities, * Epic. * Processors, * Projectors, * Repositories * Sagas, and</p>"},{"location":"riddl/future-work/","title":"Future Work","text":"<p>This section provides some insight into our plans to extend RIDDL or use it in novel ways:</p> <ul> <li>Akka source generation</li> <li>Kubernetes deployment descriptors</li> <li>Protobuffers message and service definitions</li> <li> <p>Fast data message streaming infrastructure</p> </li> <li> <p>Analyses - Produce analytical data structures    from the AST for use by translators. </p> </li> <li>BAST - Binary Abstract Syntax Tree. Generates files   that capture the abstract syntax tree (AST) in a transportable binary format</li> <li>Diagrams - Data flow, sequence, entity, context   maps, and others</li> <li>OpenAPI - OpenAPI (formerly called Swagger)   specifications for APIs implied in the RIDDL model</li> <li>Kalix - Kalix protobuffers source generation    as input to the Kalix code generator.</li> <li>Akka - Akka, protobuffers, Alpakka    infrastructure  code &amp; skeleton</li> <li>Others - plugins can be written to convert    the AST into any other kind of needed data</li> </ul>"},{"location":"riddl/future-work/#goals","title":"Goals","text":"<p>This project is currently nascent. It doesn't do anything yet, but eventually we hope it will do all the following things:</p>"},{"location":"riddl/future-work/#from-old-readme","title":"From old README ...","text":"<ul> <li>Generate Kalix Protobuffers</li> <li>Generate Swagger (OpenAPI) YAML files containing API documentation for   REST APIs</li> <li>Generate Akka Serverless based microservices to implement bounded contexts</li> <li>Generate Akka/HTTP server stubs</li> <li>Generate Akka/HTTP client library</li> <li>Generate Kafka server stubs</li> <li>Generate Kafka client library</li> <li>Generate graphQL based on domain model</li> <li>Supporting a SaaS system for the generation of the above items working   something like https://www.websequencediagrams.com/ by allowing direct   typing and immediate feedback</li> <li>Serve as the de facto (or real) standard for defining business domains and   reactive systems.</li> <li>Be designed to be used with event storming</li> <li>Designed for a fully reactive implementation with messaging between   contexts</li> <li>Support pluggable code generators for targeting different execution   environments.</li> <li>Potential executors:  Akka Data Pipelines, Akka Serverless, Akka/Scala</li> <li>Incorporate the best interface language ideas from CORBA, Reactive   Architecture, DDD, REST, DCOM, gRPC, etc.</li> <li>Support for Read Projections and Read Models (plugins for databases)</li> <li>Support for graphQL and gRPC</li> </ul>"},{"location":"riddl/future-work/akka/","title":"Akka","text":"<p>The goal of the Akka translator is to generate all the infrastructure code  needed to support the domain(s) defined in the RIDDL input. While this does  produce a working system, it also relieves developers of much of the  repetitive, detail oriented infrastructure that is relatively boring  compared to the business logic of the system. </p> <p>This translator recognizes that its output will be co-mingled with the  business logic output that developers are writing and keeps them separate.  When an expected developer file does not exist, it will create it, but  otherwise uses Scala inheritance, or other mechanisms, to indicate the  portions that ought to be written. </p>"},{"location":"riddl/future-work/akka/#output-file-types","title":"Output File Types","text":"<p>The Akka translator doesn't just generate Scala code. It aims to generate  complete projects that should be familiar to those famliar with Scala and  Akka projects. This means generating a mixture of file types, as described  in the following sections</p>"},{"location":"riddl/future-work/akka/#sbt-build-files","title":"sbt build files","text":"<p>build.sbt project/xxx.scala project/build.properties project/plugins.sbt</p>"},{"location":"riddl/future-work/akka/#protobuffers-definitions","title":"protobuffers definitions","text":"<p>Specifically processed by akka-grpc (via scalapb via protoc plugins)</p>"},{"location":"riddl/future-work/akka/#scala-code","title":"Scala code","text":""},{"location":"riddl/future-work/akka/#build-time-dependencies","title":"Build Time Dependencies","text":"<ul> <li>sbt 1.6 or later</li> <li>sbt-riddl plugin</li> <li>akka-grpc sbt plugin</li> <li>buildinfo sbt plugin</li> </ul>"},{"location":"riddl/future-work/akka/#runtime-dependencies","title":"Runtime Dependencies","text":"<ul> <li>Akka 2.6.17 (or later) including streams, http, cluster, persistence, ...</li> <li>Alpakka 3.x</li> <li>Kafka  </li> </ul>"},{"location":"riddl/future-work/akka/#comparison-to-akka-serverless","title":"Comparison To Akka Serverless","text":"<p>The Akka Translator has an objective to support both the advanced Akka Scala  developer and less knowledgeable developers. It does that by using Scala's  abstraction features but without completely disconnecting from Akka's  powerful features.  For example: * Actors are used, but in a fill-in-the-blank way. Advanced programmers can    still do more complicated things, neophytes will find it easy. * Does not use GRPC as the interface like Akka Serveless does. Scala is the    interface and there is no side-car aspect in the runtime.</p>"},{"location":"riddl/future-work/analyses/","title":"Analyses","text":""},{"location":"riddl/future-work/analyses/#usesused-by","title":"Uses/Used-by","text":"<p>Common to many programming language compilers, RIDDL too needs to be able to generate a pair of maps 1. uses = key is a definition, value is a list of definitions used by the key 2. used-by = key is a definition, value is a list of definitions that use     the key</p>"},{"location":"riddl/future-work/bast/","title":"Binary AST","text":"<p>When the <code>riddlc</code> compiler parses a RIDDL document, it translates it to an Abstract  Syntax Tree (AST) in memory. The AST is then used by other passes to validate and translate the  AST into other forms. The binary AST (BAST) translator converts the AST in memory into a binary  format that is stored for later usage.  Saving the BAST format and then reading it back into  the compiler avoids the time to both parse the RIDDL document and validate it for consistency.</p> <p>Consequently, the <code>riddlc</code> offers a translator from validated AST to BAST format and the ability  to read BAST files instead of RIDDL files. The content of a BAST file must contain a valid <code>domain</code> definition from which portions can be imported with the <code>import</code>  keyword like this:</p> <pre><code>import domain Kitchen from \"rbbq.bast\"\n</code></pre>"},{"location":"riddl/future-work/kalix/","title":"Kalix","text":"<p>The Kalix platform-as-a-service system represents one of  the easiest methods by which RIDDL models can be turned into running systems. The <code>riddlc</code> program generates Kalix style protobuffers files from the RIDDL  model. Kalix uses these files to generate Scala, Java, Javascript or Python code with a fill-in-the-blanks style for just the business logic.</p>"},{"location":"riddl/future-work/openapi/","title":"OpenAPI","text":"<p>RIDDL can generate OpenAPI (Swagger) input to document Application Programming Interfaces</p>"},{"location":"riddl/guides/","title":"Overview","text":"<p>This section contains various RIDDL guides to help you learn and use RIDDL. Guides are tailored for different kinds of users. These are  the guides we have:</p> <ul> <li>Authors - A guide for authoring RIDDL models.</li> <li>Developers - A guide for developing and maintaining RIDDL itself.</li> <li>Domain Experts - A guide for domain experts reading a previously    authored model and trying to understand it. </li> <li>Implementors - A guide for implementors of a model. These are the    people working with generative AI to produce equivalent software. </li> </ul>"},{"location":"riddl/guides/authors/","title":"Authors Guide","text":"<p>Work In Progress</p> <p>This section is being developed elsewhere. When we feel it is able to not confuse you, it will appear in stead of this notice. </p>"},{"location":"riddl/guides/developers/","title":"Developers Guide","text":"<p>Work In Progress</p> <p>This section is being developed elsewhere. When we feel it is able to not confuse you, it will appear in stead of this notice. </p>"},{"location":"riddl/guides/domain-experts/","title":"Domain Expert's Guide","text":"<p>Domain experts (DEs) are subject matter experts (SMEs) in some knowledge or problem domain. They are the authority on the language used to describe both problems and solutions within their domain or field of expertise. These individuals are recognized authorities, and they influence an organization's product, service or strategic direction.</p> <p>Domain experts may or may not be in leadership positions, but they are people who are broadly trusted for their knowledge of business rules, processes, technical details, and system requirements.</p> <p>These are the EF_Huttons of the organization since people listen to them. They may be Architects,  Analysts, Developers, Managers, Executives, or highly knowledgeable  people from anywhere in the organization that speak with authority.</p> <p>Domain Experts do not need to be well versed in DDD or Reactive Architecture initially. It is the job of the Author to act as a guide and mentor through these topics. But Domain Experts must be open to change what is for what could be. Complex distributed architectures can be very challenging for  people to digest.  More specifically, the techniques used to implement  complex distributed systems will change user experiences, expectations of consistency and availability, the means used to monitor and maintain systems and processes, and so on. Domain experts will need to understand the reasons for these changes  and be able to evangelize them as they interact with their peers.</p> <p>{{&lt; toc-tree &gt;}}</p>"},{"location":"riddl/guides/domain-experts/duties/","title":"Duties -- Domain Expert's Guide","text":"<p>The duties of the domain expert in the context or making a system specification with RIDDL are to, simply, provide their expertise. Although helpful, it is not necessary to understand all the details of RIDDL in order to collaborate with  authors and implementors on the system model's definition.</p>"},{"location":"riddl/guides/domain-experts/duties/#know-your-domain","title":"Know Your Domain","text":"<p>Whatever it is that you know as an expert, that domain knowledge is essential to the correct construction of a system model. Make sure that you do know it backwards, upside down, and inside out. Your knowledge from direct experience with the domain will be most helpful.  For example, if you only know rocket science from the  perspective of theoretical physics text books, your expertise will be theoretically  correct but practically useless without hands on experience of building rockets that successfully reach their objectives.</p>"},{"location":"riddl/guides/domain-experts/duties/#communicate-your-domain","title":"Communicate Your Domain","text":""},{"location":"riddl/guides/domain-experts/duties/#be-consistent","title":"Be Consistent","text":""},{"location":"riddl/guides/domain-experts/duties/#respect-the-expertise-of-others","title":"Respect The Expertise Of Others","text":""},{"location":"riddl/guides/domain-experts/duties/#be-open-to-new-ideas","title":"Be Open To New Ideas","text":""},{"location":"riddl/guides/domain-experts/duties/#be-patient-with-non-experts","title":"Be Patient With Non-Experts","text":""},{"location":"riddl/guides/domain-experts/relating-to-riddl/","title":"Relating To Riddl -- Domain Expert's Guide","text":"<p>Understanding RIDDL is a complex domain on its own. RIDDL uses a variety of very abstract concepts that are adept at describing the design and architecture of computing systems.  This section helps you understand </p> <p>It is up to the authors working with you to translate your expertise into a  system model that uses RIDDL. You could do that even if they weren't using RIDDL. However, since you're reading this,  we'll assume they are using RIDDL. Consequently, it will be beneficial to you and your project to be informed of the essential concepts in RIDDL. The subsections that follow will provide that for you.</p> <p>{{&lt; toc &gt;}}</p>"},{"location":"riddl/guides/domain-experts/relating-to-riddl/#message-passing-systems","title":"Message Passing Systems","text":"<p>The essential tenet of a large distributed system is the passing of messages between system components. Unlike  RPCs, APIs or function calls, messages are, essentially,  the codification of invocations of behavior on the  component to which they are sent. Even a user clicking a button implicitly delivers a \"you have been clicked\" message to the button. RIDDL models these things directly. </p>"},{"location":"riddl/guides/domain-experts/relating-to-riddl/#processor","title":"Processor","text":"<p>A processor in RIDDL, is the definition of an abstract component </p>"},{"location":"riddl/guides/domain-experts/relating-to-riddl/#message","title":"Message","text":""},{"location":"riddl/guides/domain-experts/relating-to-riddl/#effects-statements","title":"Effects (Statements)","text":""},{"location":"riddl/guides/domain-experts/relating-to-riddl/#domain","title":"Domain","text":""},{"location":"riddl/guides/domain-experts/relating-to-riddl/#context","title":"Context","text":""},{"location":"riddl/guides/domain-experts/relating-to-riddl/#concepts","title":"Concepts","text":"<p>While you could spend a few days wading through the  scores of entries in the Concepts  section, you don't really need all that complexity. There are only just a few basic ideas you need to understand:</p>"},{"location":"riddl/guides/implementors/","title":"Implementor's Guide","text":"<p>Implementors are the technical experts who implement the system defined in a RIDDL specification. These people are most often Software, QA, and DevOps Engineers. Of course, throughout implementation they will be supported by the Author(s), Domain Experts, and other related staff. Implementors use the output from the RIDDL tools to aid in their comprehension and coding of a solution that corresponds to the RIDDL system specification or model.</p> <p>It is incumbent on the author and implementation team members to keep the RIDDL sources up to date and accurate as the system evolves. The implementation team members must notify the author of changes to the model that the technical implementation necessitates.</p> <p>Implementors should be experts in Reactive Architectures. In addition, software engineers, and to a certain extent, other implementors need to be well versed in the implementation tech stack. The creators of the RIDDL language have found that Scala and Akka deployed into a cloud environment provide the best tooling and support for implementing a reactive system. It is not surprising then, that some concepts and constructs found in RIDDL have strong parallels to these tools. It must be noted, however, that reactive systems can be implemented using a variety of languages, frameworks, environments, products and tools. Cloud native offerings can be used with great effect. The critical point is, throughout implementation, reactive principles must be forefront in mind as implementation choices are made.</p> <p>It must also be stated at this point that even though it may conflict with reactive principles, the business has final say in major implementation choices. It is incumbent on the implementation team to advise decision makers on the risks and challenges that are posed by making choices that conflict with reactive principles. Factors like time, cost, user experience, business rules, availability of technical talent, strategic partners, and so on are all extremely important and may conflict with the choices of the implementation team and sound reactive architecture.</p> <p>{{&lt; toc-tree &gt;}}</p>"},{"location":"riddl/guides/implementors/ways-to-use-riddl/","title":"Different Ways To Get/Use RIDDL","text":"<p>There are several ways to get riddl software on to your computer, depending  on how you want to work. </p> <p>{{&lt; toc &gt;}}</p>"},{"location":"riddl/guides/implementors/ways-to-use-riddl/#download","title":"Download","text":"<p>This is the simplest way to get <code>riddlc</code>. It should run on Windows, Mac  and Linux. Follow these steps: * Go to the riddlc downloads page * Click on the release title you want to install * Scroll down to the \"Assets\" section * Download the riddlc-{version}.zip file * Unzip that file on your computer * Place the riddlc-{version}/bin directory in your path</p>"},{"location":"riddl/guides/implementors/ways-to-use-riddl/#staged","title":"Staged","text":"<p>To use <code>riddlc</code> locally and be able to update it with new changes without a  large download, use this approach: * <code>git clone https://github.com/ossuminc/riddl.git</code> * <code>cd riddl</code> * Put the <code>./riddlc/target/universal/stage/bin</code> directory in your PATH   variable using a full path instead of \".\" * Run <code>sbt stage</code> to build the program * To update, run <code>git pull</code> from the <code>riddl</code> cloned repository directory and   rerun <code>sbt stage</code> to rebuild.</p> <p>This allows you to both make local changes and pull in changes from others to keep your local copy of <code>riddlc</code> up to date.</p>"},{"location":"riddl/guides/implementors/ways-to-use-riddl/#integrate-with-sbt","title":"Integrate With SBT","text":"<p>TBD.</p>"},{"location":"riddl/guides/implementors/ways-to-use-riddl/#riddlsbtplugin","title":"RiddlSbtPlugin","text":"<p>To use the sdt-plugin you must first have installed riddlc by one of the above  methods. This approach allows you to run <code>riddlc</code> commands from a sbt based project. The command you configure will run first when you use the <code>compile</code> command in sbt. Follow these steps:</p> <ul> <li>In your <code>plugins.sbt</code> file, add:   `addSbtPlugin(\"com.ossuminc\" % \"sbt-riddl\" % \"{version}\"). You can find    the latest available version here</li> <li>In your <code>build.sbt</code> file, use <code>enablePlugins(SbtRiddlPlugin)</code> on your project</li> <li>Set the following sbt settings:<ul> <li><code>riddlcPath := file(\"...\")</code> This defaults to \"riddlc\" which is    appropriate if the right version is in your path; otherwise specify the   full path to the <code>riddlc</code> command</li> <li><code>riddlcOptions := Seq(\"from\", \"path/to/config/file\", \"hugo\")</code> This is    just an example, you can put any command or options you want in that    sequence. Use <code>riddlc help</code> to find out what commands you can use. </li> </ul> </li> <li>To run a translator in this way, put a <code>riddlc.conf</code> file next to the top    level <code>.riddl</code> file you want to translate. The content of that file can    specify common options and the commands you want to support from    <code>sbt-riddl</code>, like the example below, taken from the   <code>riddl-examples</code> project.    These files use    Human-Oriented-CONfiguration</li> </ul> <pre><code>common {\n    show-times = true\n    verbose = true\n    quiet = false\n    dry-run = false\n    show-warnings = true\n    show-missing-warnings = false\n    show-style-warnings = false\n}\nhugo {\n    input-file = \"ReactiveBBQ.riddl\"\n    output-dir = \"target/hugo/ReactiveBBQ\"\n    project-name = \"Reactive BBQ\"\n    site-title = \"Reactive BBQ Generated Specification\"\n    site-description = \"This site provides a specification for the Reactive BBQ application as generated by riddlc\"\n    site-logo-path = \"images/RBBQ.png\"\n    erase-output = true\n    base-url = \"https://bbq.riddl.tech\"\n    source-url = \"https://github.com/ossuminc/riddl\"\n    edit-path = \"/-/blob/main/src/riddl/ReactiveBBQ\"\n}\nvalidate {\n    input-file = \"ReactiveBBQ.riddl\"\n</code></pre>"},{"location":"riddl/introduction/","title":"Introduction","text":"<p>In this section we will explore what RIDDL is, by answering these questions:</p> <p>Click on the above links to explore this section; or, go to the next recommended section: Guides.</p>"},{"location":"riddl/introduction/how-can-i-get-help/","title":"How Can I Get Help?","text":"<p>Here are some options for getting help. Pick the item below that best fits your  needs:</p>"},{"location":"riddl/introduction/how-can-i-get-help/#i-need-a-bug-fixed","title":"I Need A Bug Fixed","text":"<p>While RIDDL is competent enough to be used  for a production software project, sometimes things aren't quite right.  Consequently, we are very eager to perfect it and your bug submission will help with that.</p> <p>Please submit your  via  GitHub at this location. In  the comment area, please ensure you do the following: * Provide the release version that the <code>riddlc version</code> command puts out. * Provide a clear statement of the symptom of the bug.  * Provide a minimal reproduction case. Usually that involves providing as    small a sample of RIDDL source code as possible that makes the symptom    happen. This will be added to RIDDL's regression test suite. NOTE: If we    can't reproduce the symptom, we cannot provide a fix to it. * Label your new issue with the \"Bug\" (red) label, so we are sure to    prioritize it.  </p>"},{"location":"riddl/introduction/how-can-i-get-help/#i-need-riddl-to-generate-something-else","title":"I Need RIDDL To Generate Something Else","text":"<p>These kinds of requests are very important to us. We are very interested in  creating a set of useful RIDDL translators for many kinds of purposes. For  these kinds of feature request, please bypass GitHub and reach out directly  to [Reid Spencer](who-made-riddl-possible.md#reid-spencer at <code>reid@ossuminc.com</code> </p>"},{"location":"riddl/introduction/how-can-i-get-help/#i-want-to-make-a-feature-suggestion","title":"I Want To Make A Feature Suggestion","text":"<p>There are many things we want to do with RIDDL, some of them may already be requested.  You can avoid adding duplicate features by checking  this list.</p> <p>We would appreciate help with implementing new features and suggest that you  clone the repository and submit a pull request. </p> <p>If your feature suggestion is not already recorded, and you're unable to  implement the feature yourself, please submit your feature suggestion via GitHub at this location.  Please ensure you do the following: * Provide a clear statement of the feature you are suggesting we implement.    Be as detailed as you can. We can handle it! :) * Label your new issue with the \"Enhancement\" (mint green) label and any    other label that helps categorize it (except \"Bug\"). </p>"},{"location":"riddl/introduction/how-can-i-get-help/#i-need-commercial-support","title":"I Need Commercial Support","text":"<p>Commercial support is available by sending an email describing your needs to Reid Spencer at <code>reid@ossuminc.com</code>. Reid will reflect upon your request and suggest a time to  have a Zoom conference call to discuss further.</p>"},{"location":"riddl/introduction/how-can-i-get-help/#i-just-want-to-chat-with-someone-about-riddl","title":"I Just Want To Chat With Someone About RIDDL","text":"<p>You can use the Discussions feature on GitHub</p>"},{"location":"riddl/introduction/what-can-riddl-do/","title":"What can RIDDL do?","text":"<p>RIDDL is a software specification language. As a consequence of it being a language, it has a software tool, <code>riddlc</code> (riddl compiler), that can be  used to do a variety of things. Most of those things involve reading riddl  input files, checking them, and producing some output file(s). </p>"},{"location":"riddl/introduction/what-can-riddl-do/#input","title":"Input","text":"<p>The input to <code>riddlc</code> is always a single file with the <code>.riddl</code> suffix.  This is a text file that contains definitions in the RIDDL syntax. While the input is specified as a single file, that could be just the top level file of a hierarchically arranged set of files that are included from  the top level file. </p>"},{"location":"riddl/introduction/what-can-riddl-do/#options","title":"Options","text":"<p>The <code>riddlc</code> program has many options but generally they control: * where more options are coming from (e.g. config files) * what kind of logging output should be generated (terse to verbose) * what kind of output should be generated</p>"},{"location":"riddl/introduction/what-can-riddl-do/#output","title":"Output","text":"<p>The <code>riddlc</code> program can produce many kinds of outputs. Being extensible, this list can grow. Currently implemented functionality includes:</p> <ul> <li>Syntax Validation - making sure that the input is syntactically correct</li> <li>Semantic Validation - making sure that the structure and referential    integrity of the input is correct. </li> <li>Specification Site - construction of <code>hugo</code> input that   can be translated into a web site to make the specification navigable and    readable</li> <li>Diagrams - generating a variety of diagrams as either PNG or mermaid input</li> <li>Kalix - generating the necessary Google Protobuffers input for Kalix to use to    generate the infrastructure for a software system. </li> </ul> <p>In the future we expect to produce translators that will also provide: * Akka - generating Akka infrastructure code with a \"fill in the blanks\"   approach for system design evolution.  * Kuberenetes - generating Kubernetes deployment descriptors, etc. </p> <ul> <li>RIDDL sources produce two kinds of output:</li> <li> <p>Specification: Specification outputs are the \"requirements\" of the domain model. Domain experts spend most of their time here - adding detail, reviewing for completeness/correctness, and establishing the domain model - which includes defining a ubiquitous language. Most of this work is done by reviewing the web site generated from RIDDL sources. Beyond textual definitions and descriptions of Domains, Contexts, Entities, Plants, Functions, etc. specification outputs may also include wireframe mockups, diagrams of various types that add clarity to the definition and interactions within the domain, for example, Context Maps, Flow Charts, Sequence Diagrams, State Machines, Entity Relationships. </p> <p>When the delivery team begins building, the system specification outputs become their guide posts as they build. Undoubtedly, the implementation team will need to engage with domain experts to get additional information and clarity as they develop. Specification outputs provide the baseline from which these conversations happen. The insights gained should be captured in the RIDDL file and new specification outputs generated to reflect these learnings.  * Implementation: Implementation outputs are intended to accelerate the efforts of the delivery team. As such, these outputs tend to be more technical in nature. Examples of these outputs would include: * Scala/Akka code stubs including user definitions, value objects, message definitions (case classes), and so on. * Test cases derived from user stories in the RIDDL spec. * Protobuf (Protocol Buffer) definitions.  * Open API Specifications (AKA Swagger) * Initial build.sbt * Initial GIT project and structure * Boilerplate CI/CD Definitions for implementation artifacts * Boilerplate infrastructure code to deploy both specification outputs and generated system sources</p> </li> </ul>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/","title":"What Conventions Does Riddl Use?","text":""},{"location":"riddl/introduction/what-conventions-does-riddl-use/#introduction","title":"Introduction","text":"<p>RIDDL is a language and therefore adopts some syntax and semantic conventions. RIDDL tries to keep its syntax and semantics very simple and tolerant of user omissions and formatting. It is intentionally simple and readable for author and reader comprehension. The following language conventions are adhered to  throughout the language for ease of use because special cases and rule  contraventions may cause confusion.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#freely-formatted","title":"Freely Formatted","text":"<p>The language is free in its formatting. Indentation is not required and its various definitions can be arranged on any line with any amount of white  space. </p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#ddd-uml-orientation","title":"DDD &amp; UML Orientation","text":"<p>RIDDL supports the definition of a variety of concepts (domain, bounded  context, entity, message, repository, etc.) taken directly from Domain Driven Design and the Unified Modeling Language.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#language-consistency","title":"Language Consistency","text":"<p>Most things in RIDDL are consistent throughout the language. We believe this makes learning the language easier since there are no exceptions to fundamental  constructs and syntax. The sections below define the consistent language features.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#declarative-definitions","title":"Declarative Definitions","text":"<p>The language is based on declarative definitions. All that means,  syntactically, is that you name something of a given type, like this: <pre><code>domain Engineering is { ??? }\n</code></pre> In this example the type is <code>domain</code> and the name is <code>Engineering</code>. The rest of the definition, <code>???</code>, contains more definitions specific to the <code>domain</code> kind of definition. You don't say how to do something, you specify the end result you want. The language aims to capture a detailed and concise definition of the abstractions that a complex system will require. It does not specify how those abstractions should be built. RIDDL is not a programming language, but its compiler can generate structurally sound code that can be completed by a software engineer or AI.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#definitions-may-be-empty-on-purpose","title":"Definitions May Be Empty On Purpose","text":"<p>You may have noticed in the preceding example, the use of a special sequence, <code>???</code>. This is a language operator that says \"this definition is empty and that's okay\". The alternative, <code>{ }</code>, is not permitted. The three question marks indicate that the definition is a work in progress. Modelling a domain can be hard work. New ideas come up that must be flushed out at a later time.  Sometimes things get left undefined. That's okay! This operator can be used as the body of any definition.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#branchs","title":"Branchs","text":"<p>Branchs are definitions that contain other, nested, definitions. Between the <code>{</code> and the <code>}</code> that define the boundaries of a definition, you may place other definitions. Such nested definitions are deemed to be contained. Not every definition is a container.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#leaves","title":"Leaves","text":"<p>Definitions that have no content (nested definitions) are referred to as <code>leaf definitions</code> or <code>leaves</code> because, like tree leaves, they occur at the extremities of the hierarchy of definitions.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#hierarchy-of-definitions","title":"Hierarchy Of Definitions","text":"<p>Definitions are specified in a strict containment hierarchy. Definitions that can contain other definitions are known as containers. For example, a domain definition is a recursively nested definition, as follows: <pre><code>domain root is {\n  domain branch is {\n    domain leaf { ??? }\n  }\n}\n</code></pre> That is, domains are definitions that can contain the definition of (sub) domains. Similarly <code>context</code> can define <code>entity</code> <pre><code>context foo is {\n  entity bar is { ??? }\n}\n</code></pre></p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#every-definition-should-be-documented","title":"Every Definition Should Be Documented","text":"<p>Every thing you can define can optionally be documented in a variety of ways. Documentation should conform to the syntax of the Common Markdown format. We call these descriptions or explanations because this is the text that is used to describe or explain the RIDDL definition, and it is used to generate documentation for the definition.  A description occurs directly after the definition's closing curly bracket and is preceded using keywords as detailed in the subsections below</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#single-literal-string","title":"Single Literal String","text":"<p>Pretty simple, like this: <pre><code>domain Engineering is { ??? } described by \"Stuff about engineering\"\ndomain SomeDomain is { ??? } explained as \"Too vague to have a good name\"\n</code></pre></p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#documentation-block","title":"Documentation Block","text":"<p>Allowing markdown syntax, like this: <pre><code>domain SomeDomain is { ??? } explained as {\n  |## Overview\n  |This domain is rather vague, it has no content.\n  |## Utility\n  |The utility of this domain is dubious because:\n  |* It has no content\n  |* Its name is not useful\n  |* It is only an example of RIDDL syntax\n}\n</code></pre></p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#file-reference","title":"File Reference","text":"<pre><code>domain Engineering is { ??? } described in file \"engineering.md\"\n</code></pre>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#url","title":"URL","text":"<p>or <pre><code>domain Engineering is { ??? } described at https://en.wikipedia.org/wiki/Engineering\n</code></pre></p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#definitions-may-have-brief-descriptions","title":"Definitions May Have Brief Descriptions","text":"<p>Every definition in RIDDL can have a <code>briefly</code> or <code>brief</code> suffix that in one short string describes the definition, such as: <pre><code>domain Engineering is { ??? } briefly \"The discipline of using natural science, mathematics,\n and design processes to create or improve systems that solve technical problems, \n or increase efficiency and productivity.\" \n</code></pre></p> <p>Brief descriptions should be short and concise, like a dictionary, and useful in a glossary of terms. Brief descriptions must precede the other kinds of descriptions, like this:</p> <pre><code>domain Engineering is { ??? } briefly \"The discipline of using natural science, mathematics,\n and design processes to create or improve systems that solve technical problems, \n or increase efficiency and productivity.\" described at https://en.wikipedia.org/wiki/Engineering \n</code></pre>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#definitions-and-references","title":"Definitions And References","text":"<p>A definition introduces a named instance of some RIDDL concept (such as <code>domain</code>,  <code>context</code> or <code>entity</code> as we have seen previously). Sometimes, we need to refer  to our definitions when defining something else. </p> <p>For example, if RIDDL supported the concepts of a Cat and a Person, then you might specify a cat named \"Smudge\" with an owner named \"Reid\" like this: <pre><code>person Reid is { ??? }\ncat Smudge {\n  owner: person Reid\n}\n</code></pre> Here is an explanation of each of these tokens: * <code>person</code> is the concept of a human being, intrinsic to RIDDL (its not, this is just an example) * <code>Reid</code> is the name (identifier) of the person being defined * <code>is</code> is an optional keyword for readability to introduce a definition * <code>{</code> is a required token that starts the definition of <code>Reid</code> the <code>person</code> * <code>???</code> is syntactic sugar meaning \"the details of this definition will be determined later\" * <code>}</code> is a required token that finishes the definition of <code>Reid</code> the <code>person</code> * <code>cat</code> is the concept of a feline being, if it were intrinsic to RIDDL * <code>Smudge</code> is the name the author wants to give to this <code>cat</code> concept * <code>{</code> is a required token that starts the definition of Smudge the cat * <code>owner</code> is the name of a property that all \"cat\" concepts have * <code>:</code> is a required token to separate the property name from its value * <code>person Reid</code> is a reference to an instance of a concept, a <code>person</code>, with name <code>Reid</code>. * <code>}</code> completes the definition of Smudge the cat.</p> <p>References to every kind of RIDDL concepts are made in this way, by stating the name of the concept (<code>cat</code> or <code>person</code> here) followed by the specific instance of that concept's name.  This is a simple convention used throughout the language for all concept types and references to them.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#file-inclusion","title":"File Inclusion","text":"<p>RIDDL allows source input to be included, inline, from other files. That is, the parser will substitute the text of an included file, replacing the <code>include</code> directive. This is much like the C preprocessor <code>#include</code> directive. RIDDL always parses the entire specification but the <code>include</code> directive allows you to organize that specification into many (even nested) files. Note that include directives are only permitted within container definitions. Doing so prevents fragments of definitions from being separated into individual files.</p> <p>For example, this is allowed: <pre><code>domain ThingAmaJig {\n#include \"thingamajig/thing-context\"\n#include \"thingamajig/ama-topic\"\n#include \"thingamajig/jig-context\"\n}\n</code></pre> while this is not: <pre><code>domain\n#include \"ThingAmaJig-domain\"\n</code></pre> because it is not specified within the contained portion of a container. A <code>domain</code> is a container, but it needs a name and that name cannot be buried in an include file. As a rule of thumb, you can always use <code>#include</code> right after an opening curly brace of a container definition.</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#directives","title":"Directives","text":"<p>RIDDL supports the notion of directives that are specified as a complete line whose first character is the hash mark. The directive extends to the end of that line. Hash marks at other locations on a line are not recognized as directives. The subsections below define the kinds of directives supported by RIDDL's compiler.</p> <p>{{&lt; hint type=warning title=\"Warning\" &gt;}} Directives have not yet been implemented in RIDDL {{&lt; /hint &gt;}}</p>"},{"location":"riddl/introduction/what-conventions-does-riddl-use/#substitutions","title":"Substitutions","text":"<p>For example: <pre><code>#define x = expialidocious\n</code></pre> defines a symbol x that has the value <code>expialidocious</code> . Wherever <code>$x</code> is seen in the input it will be replaced with <code>expialidocious</code> before being lexically interpreted by the compiler.</p> <p>{{&lt; hint type=warning title=\"Warning\" &gt;}} Substitutions have not yet been implemented in RIDDL {{&lt; /hint &gt;}}</p>"},{"location":"riddl/introduction/what-is-riddl-based-on/","title":"What is RIDDL Based On?","text":"<p>The RIDDL specification language borrows concepts from: * Domain Driven Design (DDD) * Reactive System Architecture (RSA) * C4 Model Of Software Architecture * Akka * Jacobsen Use Cases 2.0 * Agile User Stories * Behavior Driven Development (BDD) * Finite State Machines * Command/Query Separation * CQRS * Event Sourcing * Saga Pattern * Unified Modeling Language (UML)</p> <p>RIDDL aims to capture business concepts, system designs and architectural  details in a way that is consumable by business professionals yet can also be directly translated into various technical and non-technical artifacts, including:  * a documentation web-site  * various architectural diagrams (context maps, sequence diagrams, and so on) * design input to code generators (e.g. Kalix, protobuffers) * Kubernetes deployment descriptors * code scaffolding and templates that implement the design captured in the    RIDDL specification  * and more; please see the    future projects section</p> <p>Using these outputs, delivery teams are well-equipped to quickly begin the task of implementation. Regeneration of the model in subsequent  iterations of the design are accommodated and continue to provide value through the evolution of the design without interrupting the implementation.</p>"},{"location":"riddl/introduction/what-is-riddl-based-on/#domain-driven-design-ddd","title":"Domain Driven Design (DDD)","text":"<p>RIDDL is based on concepts from  DDD. This allows domain  experts and technical teams to work at a higher level of abstraction by  co-creating a ubiquitous language for the target domain enabling them to  develop a system specification that is familiar and comprehensible by business  and technical leaders alike.</p> <p>For best comprehension of the RIDDL language, it is best to be familiar with DDD concepts. For a four-minute overview  watch this video.  For a more in depth understanding we recommend reading Vaughn Vernon's more  concise book Domain Driven Design Distilled, or Eric Evans' original tome Domain Driven Design: Tackling Complexity in the Heart of Software</p>"},{"location":"riddl/introduction/what-is-riddl-based-on/#reactive-system-architecture-rsa","title":"Reactive System Architecture (RSA)","text":"<p>The Reactive Manifesto was authored in 2014 by Jonas Bon\u00e9r, David Farley, Roland Kunh, and Martin Thompson. As the computing landscape evolved and companies began to operate at \"internet scale\" it became evident that the old ways of constructing systems were not adequate. We needed an approach to system architecture back then that was fundamentally different in order to meet user expectations.</p> <p>The central thesis of reactive architectures is that the overriding objective in any system must be responsiveness. Users are conditioned to expect systems that perform well and are generally available. If these conditions are not met, users tend to go elsewhere to get what they want. That, of course, is clearly unacceptable for any business endeavor. To maintain responsive to users, a  system must deal with various responsiveness challenges: * system or component failure (resiliency) * increasing work load (scalability) * high operational cost (efficiency) * slow responses (performance) A reactive system aims to be responsive in the face of all of these challenges.  </p> <p>Without going into too much detail here, among the key means of achieving  responsiveness is to decompose the concerns of a domain into well isolated  blocks of functionality (DDD), and then, establishing clear non-blocking,  asynchronous, message-driven interfaces between them. Together, the concepts  of, Responsiveness, Elasticity, Resiliency, and Message-Driven form the basis of a Reactive Architecture.</p> <p>To get more information on Reactive Architecture please refer to the excellent 6 part course by Lightbend. You can find the first course in that series here.</p> <p>{{&lt; figure src=\"images/ReactiveArchitectureOverview.svg\" &gt;}}</p>"},{"location":"riddl/introduction/what-is-riddl-based-on/#unified-modeling-language-uml","title":"Unified Modeling Language (UML)","text":"<p>One of the key insights brought forward by UML is that it is far easier for  humans to comprehend the intended design of a system by communicating these  ideas with pictures. UML is a language of very precise graphical symbols that communicate different concerns of a system design.</p> <p>This idea has been further leveraged by other design artifacts and activities. For example, a very common DDD exercise is called Event Storming. In this  exercise a group of experts brainstorms about the things that happen, concrete events, within a system. Event Storming uses a very low fidelity tool to capture  the details of the exercise. In this exercise, traditionally events are captured first on orange sticky notes. The commands that generate those notes are then captured on blue stickies. And the actors that initiate those commands are captured on yellow stickies. And so on. More information on event storming can be found here and  here</p> <p>RIDDL uses many of the design artifacts detailed under the UML specification  to help communicate the design and intent of a system. For example, Sequence Diagrams are used extensively to document the interactions between bounded contexts in a system. A State Machine Diagram may be used to document the  lifecycle of an entity or user in a system, and so on. However, RIDDL's diagram output is not limited to UML diagrams. Peter Chen's 1971 invention of  the entity relationship diagram is very well adapted to the concept of entity in DDD. DDD also has its own diagrams: * the System Context Diagram provides a depiction of the actors, internal    systems, external systems, and how they interact (use cases). * the Context Map is a high level diagram that portrays the general    relationships between bounded contexts. * Business Use Case Diagram - same idea as the UML version but simpler</p> <p>More on that can be found here</p>"},{"location":"riddl/introduction/what-is-riddl-based-on/#jacobsen-use-cases-20","title":"Jacobsen Use Cases 2.0","text":"<p>TODO: write this section</p>"},{"location":"riddl/introduction/what-is-riddl-based-on/#agile-user-stories","title":"Agile User Stories","text":"<p>Agile user stories are used to capture the requirements of various components within a system. In RIDDL, user stories are part of an epic definition </p> <p>As a [persona], I [want to], [so that]...</p> <p>In other words, it provides WHO (persona), WHAT (want to), and WHY (so that). </p>"},{"location":"riddl/introduction/what-is-riddl-based-on/#behavior-driven-design-bdd","title":"Behavior Driven Design (BDD)","text":"Behavior-driven development was pioneered by Daniel Terhorst-North. It grew  from a response to test-driven development (TDD), as a way to help programmers on new agile teams \u201cget straight to the good stuff\u201d of knowing how to approach testing and coding, and minimize misunderstandings. BDD has evolved into both analysis and automated testing at the acceptance level. Cucumber Documentation <p>BDD provides a simple specification language named Gherkin which is used heavily in RIDDL. Even if you are not familiar with the Gherkin language, it is simple  enough and intuitive enough to be grasped quickly. </p> <p>Gherkin scenarios follow a simple structural pattern, like this: * SCENARIO: \\&lt;scenario description&gt;   * GIVEN \\&lt;a precondition&gt;   * WHEN \\&lt;an event occurs&gt;   * THEN \\&lt;take an action&gt;</p> <p>RIDDL uses this structure to define the processing that should occur when  defining how an event should be handled, when a function is invoked. Most of it is free-form natural language. Consequently, RIDDL is not a precise programming language. </p> <p>agile circles or considered BDD as a tool for testing, you have likely encountered Gherkin language. It follows the familiar, Given - When - Then format of capturing a user story. </p>"},{"location":"riddl/introduction/what-is-riddl/","title":"What Is RIDDL?","text":"<p>RIDDL gets its name from an acronym that stands for Reactive Interface with Domain Definition Language.</p> <p>RIDDL is a specification language for the niche of large, distributed, reactive, concurrent systems such as required for modern internet-scale  applications or corporate back office infrastructure. </p> <p>RIDDL is a variety of software libraries and tools, provided in  this GitHub repository, that  allow humans to work with the language to create their own derivative works. </p> <p>[<code>riddlc</code>] is a complete extensible compiler infrastructure for processing  RIDDL specifications. It uses a plugin system to allow new commands to be added to it for generating information from a RIDDL specification. For more details,  please see the tooling section</p>"},{"location":"riddl/introduction/who-can-benefit-from-riddl/","title":"Who Can Benefit From RIDDL?","text":"<p>RIDDL is technology-agnostic, but not design-agnostic. It is purposefully  aimed at the design of large scale, distributed systems based on a  reactive architecture. RIDDL allows specification of the design of a system,  without regard to programming language, cloud vendor choice, or specific  technology choices. Using RIDDL allows a living design to evolve through every stage of the development process and then through continuing maintenance and evolution of the system designed.</p> <p>Consequently, the people who can benefit from RIDDL are software development teams that want a precise and consistent way of specifying its evolving design as a guide to all stakeholders. RIDDL aims to support such teams with productivity increases by: * integrating with SBOM tools like Backstage * rapidly generating documentation with every change to keep the team on the    same page * rapidly generating interface code for things like Smithy, Protocol Buffers,   and OpenAPI * providing the software context for use with a GPT-based code generator   to speed up development and refactoring. </p>"},{"location":"riddl/introduction/who-made-riddl-possible/","title":"Who Made RIDDL Possible?","text":""},{"location":"riddl/introduction/who-made-riddl-possible/#originator","title":"Originator","text":""},{"location":"riddl/introduction/who-made-riddl-possible/#reid-spencer","title":"Reid Spencer","text":"<ul> <li>Deeply experienced system architect, software developer and entrepreneur. </li> <li>Initiated RIDDL in 2019 and started committing changes to the repository    at the end of 2021</li> <li>Founder of Reactific Software LLC which was bought by   Ossum Inc. in 2022 which he also founded.</li> </ul>"},{"location":"riddl/introduction/who-made-riddl-possible/#contributors","title":"Contributors","text":""},{"location":"riddl/introduction/who-made-riddl-possible/#james-lovell","title":"James Lovell","text":"<p>The original enthusiast, co-conspirator, shaper and user of the language, etc.  RIDDL wouldn't be where it is today without James' contributions. </p>"},{"location":"riddl/introduction/who-made-riddl-possible/#kevin-dvincenzo","title":"Kevin D'Vincenzo","text":"<p>An early implementor of a <code>hugo</code> translator that inspired much of the current  implementation. </p>"},{"location":"riddl/introduction/who-made-riddl-possible/#foundational-work","title":"Foundational Work","text":""},{"location":"riddl/introduction/who-made-riddl-possible/#bertrand-meyer","title":"Bertrand Meyer","text":"<p>For the notion of command/query separation which led to CQRS</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#bjrn-erik-pedersen","title":"Bj\u00f8rn Erik Pedersen","text":"<p>Creator of hugo</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#dan-north","title":"Daniel Terhorst-North","text":"<p>Creator of Gherkin</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#edward-f-moore-edward-moore","title":"Edward F. Moore ${#edward-moore}","text":"<p>Originator of the Finite State Machine</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#eric-brewer","title":"Eric Brewer","text":"<p>Originator of the CAP Theorem</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#eric-evans","title":"Eric Evans","text":"<p>Originated DDD and authored seminal books on DDD: * Domain-Driven Design: Tackling Complexity In The Heart Of Software * Domain-Driven Design References: Definitions and Pattern Summaries </p>"},{"location":"riddl/introduction/who-made-riddl-possible/#hector-garcia-molina-ken-salem","title":"Hector Garcia-Molina &amp; Ken Salem","text":"<p>Creators of the Saga Pattern</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#jonas-boner","title":"Jonas Bon\u00e9r","text":"<p>Creator of Akka and many distributed system patterns</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#kent-beck","title":"Kent Beck","text":"<p>Creator of eXtreme Programming</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#li-haoyi","title":"Li Haoyi","text":"<p>Creator of fastparse used to parse RIDDL.</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#robert-kaussow","title":"Robert Kaussow","text":"<p>Creator of the Geekdoc theme for  Hugo</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#simon-brown","title":"Simon Brown","text":"<p>Creator of the C4 Model For Software Architecture</p>"},{"location":"riddl/introduction/who-made-riddl-possible/#vaughn-vernon","title":"Vaughn Vernon","text":"<p>Author of Domain Driven Design Distilled</p>"},{"location":"riddl/introduction/why-is-riddl-needed/","title":"Why Is RIDDL Needed?","text":"<p>The originator of RIDDL, Reid Spencer, got to a point in his 40+ year career where the job of software development became tedious and repetitive. He decided  to do something about it.</p> <p>Notes for future content TBD: * 1990s rise of 4GLs * Insufficient existing specification languages * Something simpler for business users * Something highly translatable for code generation * Recognizing that Ai will soon write software * Need specifications that can be translated to many forms * Need something easily readable  * Self-documenting specifications</p>"},{"location":"riddl/references/","title":"Overview","text":"<p>This section contains various RIDDL reference manuals to help you learn and use RIDDL. Reference manuals are concise and technical. They are intended for AI to learn the details of RIDDL and may only be useful to a subset of the RIDDL user community. The current set of references are:</p> <ul> <li>Language Reference - a detailed description of the structure and    allowed syntax of RIDDL models. </li> <li>EBNF Grammar - a formal EBNF grammar for the RIDDL language so AI can   accurately construct RIDDL models. </li> </ul>"},{"location":"riddl/references/ebnf-grammar/","title":"Formal EBNF Grammar","text":"<p>Below is the formal Extended Backus-Naur Form (EBNF) grammar for RIDDL.  This grammar provides a precise definition of RIDDL syntax and can be used as a  reference when constructing valid RIDDL expressions. This grammar was  automaticaly extracted from the reference grammar written in Scala/fastparse  form at March 1, 2025. The maintainers will keep it up to date.  </p> <pre><code>(* RIDDL Grammar in EBNF *)\n\n(* Basic Elements *)\nletter = \"A\" | \"B\" | ... | \"Z\" | \"a\" | \"b\" | ... | \"z\" ;\ndigit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\nidentifier = simple_identifier | quoted_identifier ;\nsimple_identifier = letter { letter | digit | \"_\" | \"-\" } ;\nquoted_identifier = \"'\" { letter | digit | \"_\" | \"+\" | \"\\\\\" | \"-\" | \"|\" | \"/\" | \"@\" | \"$\" | \"%\" | \"&amp;\" | \",\" | \":\" | \" \" }+ \"'\" ;\npath_identifier = identifier { \".\" identifier } ;\nliteral_string = '\"' { string_char | escape_sequence } '\"' ;\nescape_sequence = \"\\\\\" ( \"\\\\\" | '\"' | \"a\" | \"e\" | \"f\" | \"n\" | \"r\" | \"t\" | hexEscape | unicodeEscape ) ;\nhexEscape = \"\\\\x\" digit digit [digit [digit [digit [digit [digit [digit]]]]]] ;\nunicodeEscape = \"\\\\u\" digit digit digit digit ;\ninteger = [\"+\"|\"-\"] digit {digit} ;\n\n(* Comments *)\ncomment = inline_comment | end_of_line_comment ;\ninline_comment = \"/*\" {any_char_except_end_comment} \"*/\" ;\nend_of_line_comment = \"//\" {any_char_except_newline} newline ;\n\n(* Main Structure *)\nroot = {root_content}+ ;\nroot_content = module_content | module | root_include ;\nmodule_content = domain | author | comment ;\nroot_include = \"include\" literal_string ;\n\n(* Module *)\nmodule = \"module\" identifier \"is\" \"{\" {module_content | module_include}+ \"}\" [with_metadata] ;\nmodule_include = \"include\" literal_string ;\n\n(* Domain *)\ndomain = \"domain\" identifier \"is\" \"{\" domain_body \"}\" [with_metadata] ;\ndomain_body = domain_definitions | \"???\" ;\ndomain_definitions = {domain_content}+ ;\ndomain_content = vital_definition_contents | author | context | domain | user | epic | saga | import_def | domain_include | comment ;\nimport_def = \"import\" \"domain\" identifier \"from\" literal_string ;\ndomain_include = \"include\" literal_string ;\n\n(* Context *)\ncontext = \"context\" identifier \"is\" \"{\" context_body \"}\" [with_metadata] ;\ncontext_body = context_definitions | \"???\" ;\ncontext_definitions = {context_definition}+ ;\ncontext_definition = processor_definition_contents | entity | adaptor | group | saga | streamlet | projector | repository | connector | context_include | comment ;\ncontext_include = \"include\" literal_string ;\n\n(* Entity *)\nentity = \"entity\" identifier \"is\" \"{\" entity_body \"}\" [with_metadata] ;\nentity_body = entity_definitions | \"???\" ;\nentity_definitions = {entity_content}+ ;\nentity_content = processor_definition_contents | state | entity_include ;\nstate = \"state\" identifier (\"of\" | \"is\") type_ref [with_metadata] ;\nentity_include = \"include\" literal_string ;\n\n(* Processor Definition Contents *)\nprocessor_definition_contents = vital_definition_contents | constant | invariant | function | handler | streamlet | connector | relationship ;\nvital_definition_contents = type_def | comment ;\n\n(* Type Definition *)\ntype_def = def_of_type | def_of_type_kind_type ;\ndef_of_type = \"type\" identifier \"is\" type_expression [with_metadata] ;\ndef_of_type_kind_type = aggregate_use_case identifier (scala_aggregate_definition | (\"is\" (aliased_type_expression | aggregation))) [with_metadata] ;\naggregate_use_case = \"type\" | \"command\" | \"query\" | \"event\" | \"result\" | \"record\" | \"graph\" | \"table\" ;\n\n(* Type Expressions *)\ntype_expression = cardinality(\n    predefined_types | pattern_type | unique_id_type | enumeration | sequence_type | mapping_from_to | a_set_type |\n    graph_type | table_type | replica_type | range_type | decimal_type | alternation | entity_reference_type | \n    aggregation | aggregate_use_case_type_expression | aliased_type_expression\n) ;\n\ncardinality = [\"many\"] [\"optional\"] type_expression_base [\"?\" | \"*\" | \"+\"] ;\ntype_expression_base = predefined_types | pattern_type | unique_id_type | enumeration | sequence_type | mapping_from_to | a_set_type |\n    graph_type | table_type | replica_type | range_type | decimal_type | alternation | entity_reference_type | \n    aggregation | aggregate_use_case_type_expression | aliased_type_expression ;\n\n(* Predefined Types *)\npredefined_types = string_type | currency_type | url_type | integer_predef_types | real_predef_types | time_predef_types | zoned_predef_types | decimal_type | other_predef_types ;\nstring_type = \"String\" [\"(\" [integer] \",\" [integer] \")\"] ;\ncurrency_type = \"Currency\" \"(\" iso_country_code \")\" ;\nurl_type = \"URL\" [\"(\" literal_string \")\"] ;\ninteger_predef_types = \"Boolean\" | \"Integer\" | \"Natural\" | \"Whole\" ;\nreal_predef_types = \"Current\" | \"Length\" | \"Luminosity\" | \"Mass\" | \"Mole\" | \"Number\" | \"Real\" | \"Temperature\" ;\ntime_predef_types = \"Duration\" | \"DateTime\" | \"Date\" | \"TimeStamp\" | \"Time\" ;\nzoned_predef_types = (\"ZonedDate\" | \"ZonedDateTime\") \"(\" [zone] \")\" ;\nother_predef_types = \"Abstract\" | \"Location\" | \"Nothing\" | \"UUID\" | \"UserId\" ;\nzone = {letter | digit | \":\" | \".\" | \"+\" | \"-\"} ;\n\n(* Type Expressions *)\npattern_type = \"Pattern\" \"(\" {literal_string} \")\" ;\nunique_id_type = \"Id\" \"(\" [\"entity\"] path_identifier \")\" ;\nenumeration = \"any\" [\"of\"] \"{\" enumerators \"}\" ;\nenumerators = {enumerator [\",\"]} | \"???\" ;\nenumerator = identifier [enum_value] [with_metadata] ;\nenum_value = \"(\" integer \")\" ;\nsequence_type = \"sequence\" \"of\" type_expression ;\nmapping_from_to = \"mapping\" \"from\" type_expression \"to\" type_expression ;\na_set_type = \"set\" \"of\" type_expression ;\ngraph_type = \"graph\" \"of\" type_expression ;\ntable_type = \"table\" \"of\" type_expression \"of\" \"[\" integer {\",\" integer} \"]\" ;\nreplica_type = \"replica\" \"of\" replica_type_expression ;\nreplica_type_expression = integer_predef_types | mapping_from_to | a_set_type ;\nrange_type = \"range\" \"(\" [integer] \",\" [integer] \")\" ;\ndecimal_type = \"Decimal\" \"(\" integer \",\" integer \")\" ;\nalternation = \"one\" [\"of\"] \"{\" {aliased_type_expression} \"}\" ;\nentity_reference_type = \"reference\" [\"to\"] [\"entity\"] path_identifier ;\naggregation = \"{\" aggregate_definitions \"}\" ;\naggregate_definitions = {aggregate_content [\",\"]} | \"???\" ;\naggregate_content = field | method | comment ;\naggregate_use_case_type_expression = aggregate_use_case aggregation ;\naliased_type_expression = [aggregate_use_case] path_identifier ;\nscala_aggregate_definition = \"(\" {field [\",\"]} \")\" ;\n\n(* Fields and Methods *)\nfield = identifier \"is\" field_type_expression [with_metadata] ;\nmethod = identifier \"(\" [arguments] \")\" \"is\" field_type_expression [with_metadata] ;\narguments = {method_argument [\",\"]} ;\nmethod_argument = identifier \":\" field_type_expression ;\nfield_type_expression = cardinality(\n    predefined_types | pattern_type | unique_id_type | enumeration | sequence_type | mapping_from_to | a_set_type |\n    graph_type | table_type | replica_type | range_type | decimal_type | alternation | aggregation |\n    aliased_type_expression | entity_reference_type\n) ;\n\n(* Functions *)\nfunction = \"function\" identifier \"is\" \"{\" function_body \"}\" [with_metadata] ;\nfunction_body = [func_input] [func_output] function_definitions ;\nfunc_input = \"requires\" aggregation ;\nfunc_output = \"returns\" aggregation ;\nfunction_definitions = {\"???\" | (vital_definition_contents | function | function_include | statement)} ;\nfunction_include = \"include\" literal_string ;\n\n(* References *)\ntype_ref = [aggregate_use_case] path_identifier ;\nfield_ref = \"field\" path_identifier ;\nconstant_ref = \"constant\" path_identifier ;\nmessage_ref = command_ref | event_ref | query_ref | result_ref | record_ref ;\ncommand_ref = \"command\" path_identifier ;\nevent_ref = \"event\" path_identifier ;\nquery_ref = \"query\" path_identifier ;\nresult_ref = \"result\" path_identifier ;\nrecord_ref = \"record\" path_identifier ;\nadaptor_ref = \"adaptor\" path_identifier ;\nentity_ref = \"entity\" path_identifier ;\nfunction_ref = \"function\" path_identifier ;\nhandler_ref = \"handler\" path_identifier ;\nstate_ref = \"state\" path_identifier ;\ncontext_ref = \"context\" path_identifier ;\noutlet_ref = \"outlet\" path_identifier ;\ninlet_ref = \"inlet\" path_identifier ;\nstreamlet_ref = \"streamlets\" path_identifier ;\nprojector_ref = \"projector\" path_identifier ;\nrepository_ref = \"repository\" path_identifier ;\nsaga_ref = \"saga\" path_identifier ;\nepic_ref = \"epic\" path_identifier ;\nuser_ref = \"user\" path_identifier ;\noutput_ref = output_aliases path_identifier ;\ninput_ref = input_aliases path_identifier ;\ngroup_ref = group_aliases path_identifier ;\nauthor_ref = \"by\" \"author\" path_identifier ;\nprocessor_ref = adaptor_ref | context_ref | entity_ref | projector_ref | repository_ref | streamlet_ref ;\nany_interaction_ref = processor_ref | saga_ref | input_ref | output_ref | group_ref | user_ref ;\n\n(* Handlers *)\nhandler = \"handler\" identifier \"is\" \"{\" handler_body \"}\" [with_metadata] ;\nhandler_body = {\"???\" | handler_contents} ;\nhandler_contents = {on_clause | comment} ;\non_clause = on_init_clause | on_other_clause | on_term_clause | on_message_clause ;\non_init_clause = \"on init\" \"is\" pseudo_code_block [with_metadata] ;\non_other_clause = \"on other\" \"is\" pseudo_code_block [with_metadata] ;\non_term_clause = \"on term\" \"is\" pseudo_code_block [with_metadata] ;\non_message_clause = \"on\" message_ref [\"from\" [identifier \":\"] message_origins] \"is\" pseudo_code_block [with_metadata] ;\nmessage_origins = inlet_ref | processor_ref | user_ref | epic_ref ;\n\n(* Statements *)\nstatement = send_statement | arbitrary_statement | error_statement | the_set_statement | tell_statement | call_statement |\n    stop_statement | if_then_else_statement | for_each_statement | code_statement | comment | reply_statement |\n    focus_statement | morph_statement | become_statement | return_statement | read_statement | write_statement ;\n\nsend_statement = \"send\" message_ref \"to\" (outlet_ref | inlet_ref) ;\narbitrary_statement = literal_string ;\nerror_statement = \"error\" literal_string ;\nthe_set_statement = \"set\" field_ref \"to\" literal_string ;\ntell_statement = \"tell\" message_ref \"to\" processor_ref ;\ncall_statement = \"call\" function_ref ;\nstop_statement = \"stop\" ;\nif_then_else_statement = \"if\" literal_string \"then\" pseudo_code_block [\"else\" pseudo_code_block \"end\"] ;\nfor_each_statement = \"foreach\" (field_ref | inlet_ref | outlet_ref) \"do\" pseudo_code_block \"end\" ;\ncode_statement = \"```\" (\"scala\" | \"java\" | \"python\" | \"mojo\") code_contents \"```\" ;\ncode_contents = {any_char_except_triple_backtick} ;\nreply_statement = \"reply\" [\"with\"] message_ref ;\nfocus_statement = \"focus\" \"on\" group_ref ;\nmorph_statement = \"morph\" entity_ref \"to\" state_ref \"with\" message_ref ;\nbecome_statement = \"become\" entity_ref \"to\" handler_ref ;\nreturn_statement = \"return\" literal_string ;\nread_statement = (\"read\" | \"get\" | \"query\" | \"find\" | \"select\") literal_string \"from\" type_ref \"where\" literal_string ;\nwrite_statement = (\"write\" | \"put\" | \"create\" | \"update\" | \"delete\" | \"remove\" | \"append\" | \"insert\" | \"modify\") literal_string \"to\" type_ref ;\n\n(* Pseudo Code Block *)\npseudo_code_block = \"???\" | {statement} | \"{\" {statement} \"}\" ;\n\n(* Constants and Invariants *)\nconstant = \"constant\" identifier \"is\" type_expression \"=\" literal_string [with_metadata] ;\ninvariant = \"invariant\" identifier \"is\" [literal_string] [with_metadata] ;\n\n(* Relationship *)\nrelationship = \"relationship\" identifier \"to\" processor_ref \"as\" relationship_cardinality [\"label\" \"as\" literal_string] [with_metadata] ;\nrelationship_cardinality = \"1:1\" | \"1:N\" | \"N:1\" | \"N:N\" ;\n\n(* Streamlet-related *)\nstreamlet = source | sink | flow | merge | split | router | void ;\nsource = \"source\" identifier \"is\" \"{\" streamlet_body \"}\" [with_metadata] ;\nsink = \"sink\" identifier \"is\" \"{\" streamlet_body \"}\" [with_metadata] ;\nflow = \"flow\" identifier \"is\" \"{\" streamlet_body \"}\" [with_metadata] ;\nmerge = \"merge\" identifier \"is\" \"{\" streamlet_body \"}\" [with_metadata] ;\nsplit = \"split\" identifier \"is\" \"{\" streamlet_body \"}\" [with_metadata] ;\nrouter = \"router\" identifier \"is\" \"{\" streamlet_body \"}\" [with_metadata] ;\nvoid = \"void\" identifier \"is\" \"{\" streamlet_body \"}\" [with_metadata] ;\nstreamlet_body = {\"???\" | streamlet_definition} ;\nstreamlet_definition = {inlet | outlet | streamlet_include | processor_definition_contents} ;\nstreamlet_include = \"include\" literal_string ;\ninlet = \"inlet\" identifier \"is\" type_ref [with_metadata] ;\noutlet = \"outlet\" identifier \"is\" type_ref [with_metadata] ;\nconnector = \"connector\" identifier \"is\" connector_definitions [with_metadata] ;\nconnector_definitions = [\"(\" \"from\" outlet_ref \"to\" inlet_ref \")\" | \"from\" outlet_ref \"to\" inlet_ref] ;\n\n(* Group-related *)\ngroup = group_aliases identifier \"is\" \"{\" {\"???\" | group_definitions} \"}\" [with_metadata] ;\ngroup_definitions = {group | contained_group | shown_by | group_output | group_input | comment} ;\ncontained_group = \"contains\" identifier \"as\" group_ref [with_metadata] ;\ngroup_output = output_aliases identifier presentation_aliases (literal_string | constant_ref | type_ref) [output_definitions] [with_metadata] ;\ngroup_input = input_aliases identifier acquisition_aliases type_ref [input_definitions] [with_metadata] ;\noutput_definitions = [\"is\" \"{\" {\"???\" | (group_output | type_ref)} \"}\"] ;\ninput_definitions = [\"is\" \"{\" {\"???\" | group_input} \"}\"] ;\ngroup_aliases = \"group\" | \"page\" | \"pane\" | \"dialog\" | \"menu\" | \"popup\" | \"frame\" | \"column\" | \"window\" | \"section\" | \"tab\" | \"flow\" | \"block\" ;\noutput_aliases = \"output\" | \"document\" | \"list\" | \"table\" | \"graph\" | \"animation\" | \"picture\" ;\ninput_aliases = \"input\" | \"form\" | \"text\" | \"button\" | \"picklist\" | \"selector\" | \"item\" ;\npresentation_aliases = \"presents\" | \"shows\" | \"displays\" | \"writes\" | \"emits\" ;\nacquisition_aliases = \"acquires\" | \"reads\" | \"takes\" | \"accepts\" | \"admits\" | \"initiates\" | \"submits\" | \"triggers\" | \"activates\" | \"starts\" ;\n\n(* Repository-related *)\nrepository = \"repository\" identifier \"is\" \"{\" repository_body \"}\" [with_metadata] ;\nrepository_body = {\"???\" | repository_definitions} ;\nrepository_definitions = {processor_definition_contents | schema | repository_include} ;\nrepository_include = \"include\" literal_string ;\nschema = \"schema\" identifier \"is\" schema_kind {data} {link} {index} [with_metadata] ;\nschema_kind = \"flat\" | \"relational\" | \"time-series\" | \"graphical\" | \"hierarchical\" | \"star\" | \"document\" | \"columnar\" | \"vector\" | \"other\" ;\ndata = \"of\" identifier \"as\" type_ref ;\nlink = \"link\" identifier \"as\" field_ref \"to\" field_ref ;\nindex = \"index\" \"on\" field_ref ;\n\n(* Adaptor-related *)\nadaptor = \"adaptor\" identifier adaptor_direction context_ref \"is\" \"{\" adaptor_body \"}\" [with_metadata] ;\nadaptor_direction = \"from\" | \"to\" ;\nadaptor_body = {\"???\" | adaptor_contents} ;\nadaptor_contents = {processor_definition_contents | handler | adaptor_include} ;\nadaptor_include = \"include\" literal_string ;\n\n(* Projector-related *)\nprojector = \"projector\" identifier \"is\" \"{\" projector_body \"}\" [with_metadata] ;\nprojector_body = {\"???\" | projector_definitions} ;\nprojector_definitions = {processor_definition_contents | updates | projector_include} ;\nprojector_include = \"include\" literal_string ;\nupdates = \"updates\" repository_ref ;\n\n(* Saga-related *)\nsaga = \"saga\" identifier \"is\" \"{\" saga_body \"}\" [with_metadata] ;\nsaga_body = [func_input] [func_output] {saga_definitions} ;\nsaga_definitions = {saga_step | inlet | outlet | function | term | saga_include | option} ;\nsaga_include = \"include\" literal_string ;\nsaga_step = \"step\" identifier \"is\" pseudo_code_block \"reverted\" [\"by\"] pseudo_code_block [with_metadata] ;\n\n(* Epic-related *)\nepic = \"epic\" identifier \"is\" \"{\" epic_body \"}\" [with_metadata] ;\nepic_body = user_story {epic_definitions} ;\nepic_definitions = {vital_definition_contents | use_case | shown_by | epic_include} ;\nepic_include = \"include\" literal_string ;\nuse_case = \"case\" identifier \"is\" \"{\" user_story {\"???\" | interactions} \"}\" [with_metadata] ;\nuser_story = user_ref \"wants\" [\"to\"] literal_string \"so\" [\"that\"] literal_string ;\ninteractions = {interaction} ;\ninteraction = parallel_interactions | optional_interactions | sequential_interactions | step_interactions ;\nparallel_interactions = \"parallel\" \"{\" interactions \"}\" ;\noptional_interactions = \"optional\" \"{\" interactions \"}\" ;\nsequential_interactions = \"sequence\" \"{\" interactions \"}\" ;\nstep_interactions = \"step\" (focus_on_group_step | direct_user_to_url | select_input_step | take_input_step | \n                            show_output_step | self_processing_step | send_message_step | arbitrary_step | vague_step) ;\nfocus_on_group_step = \"focus\" user_ref \"on\" group_ref [with_metadata] ;\ndirect_user_to_url = \"direct\" user_ref \"to\" http_url [with_metadata] ;\nselect_input_step = user_ref \"selects\" input_ref [with_metadata] ;\ntake_input_step = \"take\" input_ref \"from\" user_ref [with_metadata] ;\nshow_output_step = \"show\" output_ref \"to\" user_ref [with_metadata] ;\nself_processing_step = \"for\" any_interaction_ref \"is\" literal_string [with_metadata] ;\nsend_message_step = \"send\" message_ref \"from\" any_interaction_ref \"to\" processor_ref [with_metadata] ;\narbitrary_step = \"from\" any_interaction_ref literal_string [\"to\"] any_interaction_ref [with_metadata] ;\nvague_step = \"is\" literal_string literal_string literal_string [with_metadata] ;\n\n(* User-related *)\nuser = \"user\" identifier \"is\" literal_string [with_metadata] ;\n\n(* Author-related *)\nauthor = \"author\" identifier \"is\" \"{\" [(\"???\" | (\"name\" \"is\" literal_string \"email\" \"is\" literal_string \n        [\"organization\" \"is\" literal_string] [\"title\" \"is\" literal_string] [\"url\" \"is\" http_url]))] \"}\" [with_metadata] ;\n\n(* URLs *)\nhttp_url = (\"http\" | \"https\") \"://\" host_string [\":\" port_num] \"/\" [url_path] ;\nhost_string = {letter | digit | \"-\"} {\".\" {letter | digit | \"-\"}} ;\nport_num = digit {digit} ;\nurl_path = {letter | digit | \"-\" | \"_\" | \".\" | \"~\" | \"!\" | \"$\" | \"&amp;\" | \"'\" | \"(\" | \")\" | \"*\" | \"+\" | \",\" | \";\" | \"=\"} ;\n\n(* Metadata *)\nwith_metadata = [\"with\" \"{\" {\"???\" | {meta_data}} \"}\"] ;\nmeta_data = brief_description | description | term | option | author_ref | attachment | ulid_attachment | comment ;\nbrief_description = \"briefly\" [\"by\" | \"as\"] literal_string ;\ndescription = \"described\" ((\"by\" | \"as\") doc_block | (\"at\" http_url) | (\"in\" \"file\" literal_string)) ;\nterm = \"term\" identifier \"is\" doc_block ;\noption = \"option\" [\"is\"] option_name [\"(\" {literal_string} \")\"] ;\noption_name = {lower_letter | digit | \"_\" | \"-\"} ;\nattachment = \"attachment\" identifier \"is\" mime_type ((\"in\" \"file\" literal_string) | (\"as\" literal_string)) ;\nulid_attachment = \"attachment\" \"ULID\" \"is\" literal_string ;\ndoc_block = \"{\" {markdown_lines | literal_strings | \"???\"} \"}\" | literal_string ;\nmarkdown_lines = {markdown_line}+ ;\nmarkdown_line = \"|\" {any_char_except_newline} ;\nliteral_strings = {literal_string}+ ;\nshown_by = \"shown\" \"by\" \"{\" {http_url} \"}\" ;\nmime_type = (\"application\" | \"audio\" | \"example\" | \"font\" | \"image\" | \"model\" | \"text\" | \"video\") \"/\" {mime_type_chars} ;\nmime_type_chars = lower_letter | \".\" | \"-\" | \"*\" ;\n</code></pre> <p>This EBNF grammar provides a formal representation of the RIDDL language syntax. It's particularly useful for understanding the exact structure of each language element and how they relate to each other.</p>"},{"location":"riddl/references/language-reference/","title":"RIDDL Language Guide","text":""},{"location":"riddl/references/language-reference/#overview","title":"Overview","text":"<p>RIDDL (Reactive Interface to Domain Definition Language) is a domain-specific  language designed for modeling reactive systems using Domain-Driven Design (DDD) principles. It bridges the gap between business domain experts and software  engineers by providing a language that's both expressive for domain modeling and precise enough for implementation. This language was also designed to provide a GPT AI Model with sufficient context to generate code accurately from the specification. </p>"},{"location":"riddl/references/language-reference/#language-design-emphasis","title":"Language Design Emphasis","text":"<p>RIDDL emphasizes: - Declarative syntax with natural language readability - Hierarchical structure with domains, (bounded) contexts, entities, streamlets,   repositories, projectors, adaptors, and other definitions that specify the    behavior of a system.  - Event-driven and reactive design patterns - State-based entity modeling with explicit state transitions - Streaming of data between components from inlet to outlet via connectors  - Clear separation of commands, events, queries and results - Saga-based coordination of complex atomic processes and possibly distributed - Comprehensive domain modeling through DDD concepts - Asynchronous, non-blocking communications (implied)</p>"},{"location":"riddl/references/language-reference/#language-structure","title":"Language Structure","text":""},{"location":"riddl/references/language-reference/#definitions","title":"Definitions","text":"<p>Everything that has a name and can have metadata is known as a Definition in RIDDL.</p>"},{"location":"riddl/references/language-reference/#branches","title":"Branches","text":"<p>Every </p>"},{"location":"riddl/references/language-reference/#processors","title":"Processors","text":""},{"location":"riddl/references/language-reference/#domain-hierarchy","title":"Domain Hierarchy","text":"<p>RIDDL models are organized hierarchically: - Root: The top-level container for the entire system. Roots are not defined but    consist of the top level definitions in a file. Roots can contain Modules,   Domains, and Authors - Nebula: The top-level container to be used as a scratch pad. It can contain any of the main   definitions without regard to structure.  - Module: A way of modularizing root content for large models that need to save compilation    output  - Domain: A container for the specification of some knowledge domain. Domains    may only contain Contexts - Context: Bounded context containing related entities and components. Also used to model   user interfaces from their data flow perspective.  - Entity: Stateful business objects with commands, events, and handlers - Repository: Persistent storage for entities - Projector: A component that projects messages, typically events, to a repository for later    retrieval, possibly transforming the data or merging multiple streams of events.  - Saga: A component that defines the orchestration of multi-step atomic process with    compensation actions to undo the process when errors arise. - Epic: A collection of use cases to show an expected usage pattern - Case: A Specific user interaction flow</p> <p>The hierarchy </p>"},{"location":"riddl/references/language-reference/#data-types","title":"Data Types","text":"<p>Riddl has a rich </p>"},{"location":"riddl/references/language-reference/#basic-syntax-elements","title":"Basic Syntax Elements","text":"<ol> <li>Readability Words: Optional words that improve human readability of a model</li> <li>The complete list is: <code>and</code>, <code>are</code>, <code>as</code>, <code>at</code>, <code>by</code>, <code>for</code>, <code>from</code>, <code>in</code>, <code>is</code>, <code>of</code>, <code>so</code>,      <code>that</code>, <code>to</code>,  and <code>wants</code></li> <li>A synonym for <code>is</code> is <code>:</code></li> <li> <p>These words are accepted by the grammar but not required. </p> </li> <li> <p>Definition Structure:    <pre><code>[type] [name] is {\n  // definition contents\n} with {\n  // meta data\n}\n</code></pre></p> </li> <li>The <code>[type]</code> indicates the kind of definition (domain, context, entity, etc.)</li> <li>The <code>[name]</code> is the identifier for this definition which must be unique amongst its peers.</li> <li> <p>The \"definition contents\" depend on the <code>[type]</code> of definition being defined.     The metadata section (with <code>briefly</code> and <code>described by</code>) must always come     after the closing brace of the definition, not within it.</p> </li> <li> <p>Type References: Always specify the kind of reference</p> </li> <li><code>entity Product</code></li> <li><code>command CreateCart</code></li> <li><code>event OrderCreated</code></li> <li><code>state ProductData</code></li> <li><code>user Customer</code></li> </ol>"},{"location":"riddl/references/language-reference/#containment-rules","title":"Containment Rules","text":"<p>RIDDL follows strict containment rules that define what elements can be defined within other elements:</p> <ol> <li>Domain can contain:</li> <li>Authors (metadata)</li> <li>Types</li> <li>Contexts</li> <li>Nested Domains</li> <li>Users</li> <li> <p>Epics</p> </li> <li> <p>Context can contain:</p> </li> <li>Types</li> <li>Entities</li> <li>Repositories</li> <li>Sagas</li> <li>Streamlets</li> <li> <p>Pages (UI components)</p> </li> <li> <p>Entity can contain:</p> </li> <li>States</li> <li>Commands</li> <li>Events</li> <li>Functions</li> <li> <p>Handlers</p> </li> <li> <p>Authors contain only their metadata and cannot contain any other RIDDL definitions.</p> </li> </ol>"},{"location":"riddl/references/language-reference/#type-system","title":"Type System","text":""},{"location":"riddl/references/language-reference/#basic-types","title":"Basic Types","text":"<ul> <li><code>UUID</code>, <code>String(min, max)</code>, <code>Integer</code>, <code>Decimal(whole, fractional)</code></li> <li><code>Boolean</code>, <code>Pattern(\"regex\")</code>, <code>Real</code>, <code>Natural</code>, etc.</li> </ul>"},{"location":"riddl/references/language-reference/#complex-types","title":"Complex Types","text":"<ul> <li> <p>Record Types: Named collections of fields   <pre><code>type Address is {\n  street1 is String\n  city is String\n  state is String\n  zipCode is String\n  country is String\n} with {\n  briefly as \"Physical mailing address\"\n  described by {\n    | Represents a physical address with standard components\n    | used for shipping and billing purposes.\n  }\n}\n</code></pre></p> </li> <li> <p>Enumerations:   <pre><code>type Status is any of {\n  Active\n  Inactive\n  Suspended\n} with {\n  briefly as \"Possible entity statuses\"\n  described by {\n    | Defines the possible states for an entity's lifecycle.\n  }\n}\n</code></pre></p> </li> <li> <p>Collections:   <pre><code>items is many Item\n</code></pre></p> </li> </ul>"},{"location":"riddl/references/language-reference/#entities-and-states","title":"Entities and States","text":"<p>Entities are stateful objects with explicit states:</p> <pre><code>entity Product is {\n  state ProductData of ProductRecord with {\n    briefly as \"Product state containing all product information\"\n    described by {\n      | Contains the complete product information including identification,\n      | pricing, and inventory information.\n    }\n  }\n\n  // Commands, events, handlers\n} with {\n  briefly as \"Represents a purchasable item\"\n  described by {\n    | The Product entity represents items that can be purchased.\n    | It contains all product attributes and responds to commands.\n  }\n}\n</code></pre> <p>States reference record types that define the data structure:</p> <pre><code>type ProductRecord is {\n  id is ProductId\n  name is Name\n  price is Price\n  // other fields\n} with {\n  briefly as \"Record type containing product data\"\n  described by {\n    | Defines the structure of product data including identification and pricing.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#commands-and-events","title":"Commands and Events","text":"<p>Commands represent requests to change state:</p> <pre><code>command UpdatePrice is {\n  productId is ProductId\n  newPrice is Price\n} with {\n  briefly as \"Command to change a product's price\"\n  described by {\n    | Updates the price of a specific product identified by productId.\n    | The new price must be a positive value.\n  }\n}\n</code></pre> <p>Events represent state changes that have occurred:</p> <pre><code>event PriceUpdated is {\n  productId is ProductId\n  oldPrice is Price\n  newPrice is Price\n} with {\n  briefly as \"Event indicating a product price change\"\n  described by {\n    | Emitted when a product's price is successfully updated.\n    | Contains both old and new prices for auditing and UI updates.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#command-event-relationship","title":"Command-Event Relationship","text":"<p>Commands should always result in one or more events being emitted. This follows the reactive principles of RIDDL:</p> <pre><code>handler ProductCommandHandler is {\n  on command UpdatePrice is {\n    if \"newPrice &gt; 0\" then {\n      morph entity Product to state ProductData with command UpdatePrice\n      tell event PriceUpdated to entity Product  // Emitting an event is essential\n    } else {\n      error \"Price must be greater than zero\"\n    } end\n  }\n} with {\n  briefly as \"Processes commands for product management\"\n  described by {\n    | Handles commands related to product information management.\n    | Validates input data, updates product state, and emits relevant events.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#handlers","title":"Handlers","text":"<p>Handlers process commands and emit events:</p> <pre><code>handler ProductCommandHandler is {\n  on command UpdatePrice is {\n    if \"newPrice &gt; 0\" then {\n      morph entity Product to state ProductData with command UpdatePrice\n      tell event PriceUpdated to entity Product\n    } else {\n      error \"Price must be greater than zero\"\n    } end\n  }\n} with {\n  briefly as \"Processes commands for product management\"\n  described by {\n    | Handles commands related to product information and pricing management.\n    | Validates input data, updates product state, and emits relevant events.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#statement-syntax","title":"Statement Syntax","text":""},{"location":"riddl/references/language-reference/#morph-statement","title":"Morph Statement","text":"<p>Changes entity state: <pre><code>morph entity Product to state ProductData with command UpdatePrice\n</code></pre></p>"},{"location":"riddl/references/language-reference/#tell-statement","title":"Tell Statement","text":"<p>Sends events or commands: <pre><code>tell event ItemAdded to entity Cart\ntell command ProcessPayment to entity PaymentService\n</code></pre></p>"},{"location":"riddl/references/language-reference/#set-statement","title":"Set Statement","text":"<p>Assigns values: <pre><code>set field status to \"Active\"\n</code></pre></p>"},{"location":"riddl/references/language-reference/#if-statement","title":"If Statement","text":"<p>Conditional logic: <pre><code>if \"condition\" then {\n  // actions\n} else if \"another condition\" then {\n  // actions\n} else {\n  // actions\n} end\n</code></pre></p> <p>The <code>end</code> keyword is required to terminate if statements.</p>"},{"location":"riddl/references/language-reference/#foreach-statement","title":"Foreach Statement","text":"<p>Iteration: <pre><code>foreach field Cart.items do {\n  // actions for each item\n} end\n</code></pre></p> <p>The <code>end</code> keyword is required to terminate foreach loops.</p>"},{"location":"riddl/references/language-reference/#arbitrary-statement","title":"Arbitrary Statement","text":"<p>Allows for implementation code inside functions and handler actions: <pre><code>\"var subtotal = 0;\n for (var i = 0; i &lt; items.length; i++) {\n   subtotal += items[i].totalPrice;\n }\n return subtotal;\"\n</code></pre></p>"},{"location":"riddl/references/language-reference/#functions","title":"Functions","text":"<p>Functions define reusable operations:</p> <pre><code>function calculateTotal is {\n  requires {\n    subtotal is Price\n    taxes is Price\n    shipping is Price\n    discount is Price\n  }\n  returns {\n    total is Price\n  }\n\n  // Implementation using arbitrary statement\n  \"return subtotal + taxes + shipping - discount;\"\n} with {\n  briefly as \"Calculates the final cart total\"\n  described by {\n    | Calculates the final amount by adding subtotal, taxes, and shipping,\n    | then subtracting any discounts.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#sagas","title":"Sagas","text":"<p>Sagas coordinate multi-step processes with compensation:</p> <pre><code>saga CheckoutProcess is {\n  requires {\n    cartId is CartId\n    customerInfo is CustomerInfo\n  }\n\n  returns {\n    success is Boolean\n    orderId is UUID\n  }\n\n  step ProcessPayment is {\n    // Payment processing logic\n    tell command ProcessPayment to entity PaymentService\n  } reverted by {\n    // Compensation logic to refund\n    tell command RefundPayment to entity PaymentService\n  } with {\n    briefly as \"Processes payment for the order\"\n    described by {\n      | Attempts to process payment using the provided payment details.\n      | If payment fails, the checkout process is aborted.\n      | If later steps fail, payment is refunded as part of compensation.\n    }\n  }\n\n  // Additional steps\n} with {\n  briefly as \"Orchestrates the checkout process steps\"\n  described by {\n    | This saga orchestrates the multi-step process of completing a checkout,\n    | including validating the cart and inventory, processing payment,\n    | creating an order, and sending confirmation.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#repositories","title":"Repositories","text":"<p>Repositories define persistence:</p> <pre><code>repository CartRepository is {\n  schema CartData is relational of\n    cart as Cart\n    link cartItems as field Cart.items.id to field Product.id\n\n  handler CartRepositoryHandler is {\n    on event CartCreated is {\n      write \"Create new cart record\" to Cart\n    }\n\n    // Other event handlers\n  } with {\n    briefly as \"Handles persistence of cart events\"\n    described by {\n      | Handles all event-driven persistence operations related to shopping carts.\n      | Responds to cart events by updating the persistent state of carts.\n    }\n  }\n} with {\n  briefly as \"Persistent storage for shopping cart data\"\n  described by {\n    | The CartRepository provides persistent storage for shopping cart data,\n    | including the cart itself and all items within it.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#ui-components","title":"UI Components","text":"<p>RIDDL supports UI modeling:</p> <pre><code>context UserInterface is {\n  page ProductDetails is { /* ... */ } with {\n    briefly as \"Page showing product information\"\n    described by {\n      | Displays detailed information about a product including name,\n      | description, price, and images.\n    }\n  }\n\n  page ShoppingCart is {\n    button Checkout activates type Boolean with {\n      briefly as \"Checkout button to proceed to payment\"\n      described by {\n        | Button that initiates the checkout process when clicked.\n        | Transitions the user from the shopping cart view to the \n        | checkout information entry page.\n      }\n    }\n  } with {\n    briefly as \"Page showing cart contents\"\n    described by {\n      | Displays all items added to the cart with quantities and prices.\n      | Allows customers to update quantities and proceed to checkout.\n    }\n  }\n\n  page Payment is {\n    form PaymentEntry submits type PaymentDetails with {\n      briefly as \"Form for entering payment information\"\n      described by {\n        | Collects payment method and details from the customer.\n        | Payment information is tokenized for security before processing.\n      }\n    }\n  } with {\n    briefly as \"Page for payment processing\"\n    described by {\n      | Allows customers to enter and submit payment information.\n    }\n  }\n} with {\n  briefly as \"User interface components for the system\"\n  described by {\n    | Contains all UI components used in the system including\n    | product details, shopping cart, and checkout pages.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#epics-and-use-cases","title":"Epics and Use Cases","text":"<p>Epics model user stories:</p> <pre><code>epic ShoppingCartEpic is {\n  user Customer wants to \"add items to a shopping cart\" \n  so that \"they can purchase multiple items at once\"\n\n  case AddingToCart is {\n    user Customer wants to \"add products to cart\" \n    so that \"they can purchase them later\"\n\n    step from user Customer \"views\" page UserInterface.ProductDetails\n    step send command AddToCart from user Customer to entity Cart\n    step from entity Cart \"updates\" to page UserInterface.ShoppingCart\n    step focus user Customer on page UserInterface.ShoppingCart\n  } with {\n    briefly as \"Adding products to the shopping cart\"\n    described by {\n      | This use case describes the process of a customer adding a product\n      | to their shopping cart from a product detail page.\n    }\n  }\n\n  // Additional cases\n} with {\n  briefly as \"User stories related to shopping cart management\"\n  described by {\n    | This epic covers the core shopping cart functionality including\n    | adding items to carts, updating quantities, and removing items.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#metadata-placement","title":"Metadata Placement","text":"<p>Metadata should always be placed after the closing brace of the definition, not within it:</p> <p>Correct: <pre><code>entity Product is {\n  // Entity definition content\n} with {\n  briefly as \"Product available for purchase\"\n  described by {\n    | Represents a product in the catalog that customers can purchase.\n    | Contains pricing, inventory, and product details.\n  }\n}\n</code></pre></p> <p>Incorrect: <pre><code>entity Product is {\n  // Entity definition content\n  with {  // &lt;-- This is wrong\n    briefly as \"Product available for purchase\"\n    described by {\n      | Represents a product in the catalog that customers can purchase.\n      | Contains pricing, inventory, and product details.\n    }\n  }\n}\n</code></pre></p>"},{"location":"riddl/references/language-reference/#best-practices","title":"Best Practices","text":"<ol> <li>Include Metadata: Add descriptions to all definitions with <code>with</code> clauses after their closing braces</li> <li>Be Explicit: Always specify reference types (entity, command, event, etc.)</li> <li>Place Functions Close to Usage: Define functions within the entities that use them</li> <li>End Control Structures: Always terminate control structures with <code>end</code> keyword</li> <li>Use Field References: In foreach loops, use <code>foreach field X.items</code></li> <li>Provide Default Actions: Use <code>\"nothing\"</code> for empty else branches</li> <li>Model Complete Flows: Include UI components and user interactions</li> <li>Maintain Semantic Consistency: Use the same field names for the same concepts</li> <li>Emit Events from Commands: Ensure commands emit events to follow reactive principles</li> <li>Document UI Components: Provide clear descriptions for UI elements that interact with users</li> <li>Follow Containment Rules: Only define elements within their appropriate containers (domain, context, entity, etc.)</li> <li>Separate Metadata: Always place metadata sections after a definition's closing brace, never inside it</li> </ol>"},{"location":"riddl/references/language-reference/#common-syntax-issues","title":"Common Syntax Issues","text":"<ol> <li>Don't use assignment operators (<code>=</code>); use <code>set field x to \"value\"</code></li> <li>Don't forget <code>end</code> after if statements and foreach loops</li> <li>Always include reference types before identifiers</li> <li>Use proper syntax for function parameters and return values</li> <li>Make sure all morph/tell statements have correct type references</li> <li>Place comments only where definitions are allowed, not within clauses</li> <li>Ensure metadata blocks follow their definitions rather than being nested within them</li> <li>Never place entity, type, or repository definitions directly within a domain - they must be in a context</li> <li>Never place definitions inside an author - authors only contain metadata</li> <li>Make sure each context contains related definitions that form a bounded context</li> </ol>"},{"location":"riddl/references/language-reference/#incomplete-definitions","title":"Incomplete Definitions","text":"<p>Use <code>???</code> as a placeholder for incomplete definitions:</p> <pre><code>record PaymentDetails is { ??? } with {\n  briefly as \"Record for payment information details\"\n  described by {\n    | Contains all payment information required for processing.\n  }\n}\n\npage Checkout is { ??? } with {\n  briefly as \"Checkout page for completing purchase\"\n  described by {\n    | Allows customers to review items and provide checkout information.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#author-inheritance","title":"Author Inheritance","text":"<p>Authors are defined once and inherited throughout the model hierarchy, but cannot contain any definitions:</p> <pre><code>domain ShopifyCart is {\n  author Claude is {\n    name is \"Anthropic Claude\"\n    email is \"support@anthropic.com\"\n  } with {\n    briefly as \"Model creator and maintainer\"\n    described by {\n      | Primary architect responsible for designing this model.\n    }\n  }\n\n  // All definitions within the domain inherit Claude as author\n  context ShoppingContext is {\n    // No need to repeat author information here\n  } with {\n    briefly as \"Main shopping context containing commerce entities\"\n    described by {\n      | The ShoppingContext is the primary bounded context for the shopping system.\n    }\n  }\n} with {\n  briefly as \"Shopping cart domain model\"\n  described by {\n    | This domain model represents a shopping cart system.\n    | It includes core entities, commands, events, and processes.\n  }\n}\n</code></pre>"},{"location":"riddl/references/language-reference/#additional-syntax-clarifications","title":"Additional Syntax Clarifications","text":"<p>From the formal grammar analysis, several important syntax points deserve special emphasis:</p> <ol> <li> <p>Sequential Execution: Statement blocks are executed sequentially, and while actions appear to flow naturally, there's no \"implicit flow\" - each action in handlers and functions must be explicitly defined.</p> </li> <li> <p>Reference Type Consistency: When referring to entities, commands, events, etc., always use the correct reference type (e.g., <code>entity Product</code>, not just <code>Product</code>).</p> </li> <li> <p>Nested Element Validation: Elements can only be nested within specific parent elements according to strict containment rules. For example, types must be defined within contexts, not directly within domains.</p> </li> <li> <p>Termination of Statements: Control flow statements must be properly terminated:</p> </li> <li>If statements must end with the <code>end</code> keyword</li> <li>Foreach loops must end with the <code>end</code> keyword</li> <li> <p>Other statements are implicitly terminated</p> </li> <li> <p>Handler Clauses: Handlers must use specific clause types:</p> </li> <li><code>on command X</code> for command handlers</li> <li><code>on event X</code> for event handlers</li> <li><code>on init</code> for initialization</li> <li><code>on term</code> for termination</li> <li> <p><code>on other</code> for default/catch-all behavior</p> </li> <li> <p>Readability Words: While readability words like <code>is</code>, <code>as</code>, <code>by</code>, etc. are often optional, their proper placement significantly improves model clarity. Use them consistently.</p> </li> </ol>"},{"location":"riddl/tools/","title":"Tools","text":"<p>There are several tools related to using RIDDL</p>"},{"location":"riddl/tools/#riddlc","title":"riddlc","text":"<p>This is the compiler for RIDDL that allows you to parse and validate a RIDDL model as well as reformat it, get statistics, and other utilities. </p>"},{"location":"riddl/tools/#riddl-idea-plugin","title":"riddl-idea-plugin","text":"<p>This is a plugin for IntelliJ IDEA 24.3 or later. It provides visual editing of</p>"},{"location":"riddl/tools/#synapify","title":"Synapify","text":"<p>This is a workstation application allowing you to use AI to create models and to initiate other tools for working with RIDDL models. See the  Synapify Section for more details.</p>"},{"location":"riddl/tools/riddl-idea-plugin/","title":"RIDDL IDEA Plugin","text":"<p>TBD</p>"},{"location":"riddl/tools/riddlc/","title":"RIDDLC Validator","text":""},{"location":"synapify/","title":"Synapify","text":"<p>Synapify is the editor for creating system models based on RIDDL </p>"},{"location":"verify/","title":"Verify","text":"<p>Verify is the tool that verifies the integrity, validity and logical consistency of your system model based on RIDDL</p>"}]}